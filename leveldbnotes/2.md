>reader

>sstable

>BlockBuilder

>TableBuilder

>TableCache
---

# 一、一句话先立住概念

> **`log::Reader` 的职责只有一个：
> 从 `.log` 文件中，按顺序、可靠地读出一条条“完整的逻辑记录（WriteBatch）”。**

注意几个关键词：

* **顺序**
* **完整**
* **逻辑记录**
* **即使记录被拆碎了**

---

# 二、为什么需要 Reader？（这是核心）

### 问题背景：日志不是“一条一条存”的

LevelDB 的 WAL 文件 **不是这样存的**：

```text
[WriteBatch1][WriteBatch2][WriteBatch3]
```

而是这样 👇

```text
| 32KB Block | 32KB Block | 32KB Block | ...
```

每个 **Block 里有很多 Record Fragment**：

```text
| header | data | header | data | ...
```

而 **一个 WriteBatch 可能**：

* 完全在一个 block 里
* 横跨多个 block
* 被拆成多个 fragment

👉 **Reader 的存在，就是为了解决“碎片拼接”的问题**

---

# 三、log::Reader 在哪里用？

只在两个地方：

### 1️⃣ 数据库启动时（崩溃恢复）

```cpp
DB::Recover()
  → RecoverLogFile()
     → log::Reader
```

### 2️⃣ 测试 / 工具读取日志

⚠️ **运行时 Get / Put 完全不会用 Reader**

---

# 四、Reader 的输入和输出

### 输入

* 一个 `.log` 文件（顺序读）
* 底层是 `SequentialFile`

### 输出

* 一条条 **完整的 record（Slice）**
* 每条 record = **一个 WriteBatch 的序列化数据**

```cpp
Slice record;
reader.ReadRecord(&record, &scratch);
```

---

# 五、日志的底层格式（理解 Reader 的前提）

## 1️⃣ 日志以 32KB 为一个 block

```cpp
static const size_t kBlockSize = 32768;
```

---

## 2️⃣ 每条记录都有 7 字节 header

```text
| crc (4B) | length (2B) | type (1B) |
```

### type 有 4 种（非常重要）

```cpp
enum RecordType {
  kZeroType   = 0,
  kFullType   = 1,  // 一条完整记录
  kFirstType  = 2,  // 多段记录的第一段
  kMiddleType = 3,  // 中间段
  kLastType   = 4   // 最后一段
};
```

---

# 六、Reader 的核心逻辑（一步一步）

下面是 **Reader::ReadRecord 的真实思路**（不是伪概念）

---

## 🧭 Step 1：从文件读一个 block（32KB）

```cpp
file_->Read(kBlockSize, &buffer, scratch);
```

Reader 内部维护：

* `buffer_`
* `end_of_buffer_offset_`

---

## 🧭 Step 2：从 block 里解析 header

```text
| crc | length | type |
```

* 检查 length 合不合法
* 检查 crc（如果开启）

---

## 🧭 Step 3：根据 type 决定怎么处理

### 情况一：kFullType（最爽）

```text
[FULL][data]
```

👉 直接返回这条 record
👉 **一个 WriteBatch**

---

### 情况二：kFirstType → kMiddleType → kLastType

```text
[FIRST][data1]
[MIDDLE][data2]
[LAST][data3]
```

Reader 会：

1. 清空 scratch
2. append data1
3. append data2
4. append data3
5. 返回 **拼接后的完整 record**

---

### 情况三：坏数据 / 不完整

* CRC 错
* length 越界
* 崩溃留下的半条记录

👉 **直接丢弃，不 crash**

这就是 LevelDB 的鲁棒性来源之一。

---

## 🧭 Step 4：返回 Slice（指向 scratch）

```cpp
*record = Slice(scratch->data(), scratch->size());
return true;
```

---

# 七、Reader 的内部状态（你看源码会很清晰）

Reader 维护这些关键状态：

```cpp
SequentialFile* file_;
char buffer_[kBlockSize];
size_t buffer_offset_;
bool eof_;
uint64_t last_record_offset_;
```

👉 **它是一个“状态机”**

每次 ReadRecord 都是在上一次基础上继续读。

---

# 八、Reader 和 WriteBatch 的关系

非常重要的一点：

> **Reader 完全不知道 WriteBatch 的存在**

它只做一件事：

```text
字节碎片 → 逻辑 record（Slice）
```

然后交给上层：

```cpp
WriteBatchInternal::SetContents(&batch, record);
```

👉 解耦设计，干净漂亮

---

# 九、为什么设计成这样？（架构视角）

### 1️⃣ 解决大记录跨 block 问题

* WriteBatch 可能很大
* 不要求一次写完

### 2️⃣ 崩溃容忍

* 最后一个 record 可以是半截
* Reader 会安全跳过

### 3️⃣ 顺序 IO 极致优化

* 不 seek
* 不回退
* cache-friendly

---

# 十、一句话终极总结

> **log::Reader =
> 一个“容错的、顺序的、能自动拼碎片的日志读取器”**

它的职责边界非常清晰：

| 模块            | 负责什么             |
| ------------- | ---------------- |
| LogWriter     | 把 WriteBatch 拆碎写 |
| **LogReader** | **把碎片拼回来**       |
| WriteBatch    | 解析语义             |
| DB::Recover   | 执行业务逻辑           |

---
在 LevelDB 中，**SSTable**（**Sorted String Table**）是用来存储数据库中所有数据的核心数据结构。每个 **SSTable** 文件本质上是一个有序的键值对集合，所有的键都按照字典序进行排序。LevelDB 使用 SSTable 文件来持久化和读取数据，并在它的**层级存储**架构中扮演了至关重要的角色。

### SSTable 主要的作用：

* **数据存储**：在内存中的 **MemTable** 达到一定大小时，数据会被刷写到磁盘中的 **SSTable 文件**，这部分数据之后就不再存在于内存中，而是持久化到磁盘上。
* **数据检索**：LevelDB 使用 SSTable 存储数据，在进行查询时会根据键的顺序高效地查找对应的值。

---

### 一、SSTable 文件结构

每个 SSTable 文件包含以下几个重要部分：

1. **文件头（File MetaData）**
   记录关于 SSTable 文件的基本信息，如文件的大小、SSTable 中包含的键值对的数量、文件的版本等。

2. **键值对（Key-Value Pairs）**
   这些是文件的主体部分。每个键值对是有序存储的，按照键的字典顺序排列。LevelDB 使用 **跳表**（SkipList）来生成这些有序键值对。

3. **索引（Index）**
   为了加速查找，SSTable 文件内部还包括了键的索引。该索引存储了键的位置信息，以便在进行查询时能够快速定位到键对应的值。

4. **过滤器（Bloom Filter）**
   SSTable 使用 **Bloom Filter** 来优化查询性能。Bloom Filter 是一种空间效率非常高的概率型数据结构，能够在常数时间内判断某个键是否存在于 SSTable 中。如果 Bloom Filter 判断某个键不存在，则 LevelDB 可以跳过当前 SSTable 文件，从而减少不必要的磁盘 I/O。

5. **尾部（Footer）**
   尾部包含了关于索引、过滤器等信息的元数据，用于快速访问。

---

### 二、SSTable 的文件格式

一个 SSTable 文件通常包含以下结构：

1. **Header (文件头)**

   * 文件头包含一些元信息，用于描述该文件的版本、大小、键值对数量等。

2. **数据块（Data Blocks）**

   * SSTable 的主体部分，每个数据块存储一定数量的键值对，并按键值的字典顺序排列。
   * 数据块内部会用到压缩技术，例如 **Snappy**，以减小磁盘占用空间。

3. **块索引（Block Index）**

   * 块索引记录了数据块的位置，允许快速定位数据块。

4. **过滤器（Bloom Filter）**

   * 用于加速查找过程，防止不必要的磁盘 I/O。

5. **文件尾（Footer）**

   * 文件尾包含了索引、过滤器等的偏移量。

#### 数据块的结构（简化版）

假设我们有一个包含若干个键值对的 SSTable 文件，其中每个数据块包含若干个键值对，数据块的结构可能如下所示：

```text
| Block Header | Key 1 | Value 1 | Key 2 | Value 2 | Key N | Value N |
```

1. **Block Header**：描述这个数据块的元信息，包含键值对的数量等信息。
2. **Key-Value Pairs**：每个键值对是按键的字典顺序排列的。键和值的大小是可变的，因此需要存储键和值的长度信息。

---

### 三、SSTable 的读取过程

LevelDB 在读取 SSTable 文件时，会按照以下步骤进行操作：

#### 1. **使用 Bloom Filter 判断键是否存在**

首先，LevelDB 会通过 **Bloom Filter** 判断目标键是否可能存在于 SSTable 文件中。如果 Bloom Filter 认为目标键不可能在该文件中，LevelDB 会跳过当前的 SSTable 文件，避免不必要的磁盘 I/O。

#### 2. **查找索引**

如果 Bloom Filter 认为键可能存在，LevelDB 会查找 **SSTable 索引**。SSTable 索引提供了一个快速定位机制，通过在文件中的位置，帮助 LevelDB 快速找到键值对所在的数据块。

#### 3. **从数据块中获取数据**

一旦索引定位到目标数据块，LevelDB 就会直接从数据块中读取对应的键值对。由于数据块中的键值对是按键的字典顺序排列的，LevelDB 通过 **二分查找** 或类似的技术高效地查找对应的键值对。

#### 4. **返回数据**

如果在 SSTable 中找到了目标键，LevelDB 就会返回该键对应的值。如果没有找到，LevelDB 会继续在其他 SSTable 文件中查找，或者返回 **NotFound** 状态。

---

### 四、SSTable 的写入过程

SSTable 的写入通常在内存中的 **MemTable** 满了之后进行。具体步骤如下：

1. **MemTable 滿了**
   当 MemTable 达到一定大小时，LevelDB 会将 MemTable 中的数据持久化为 SSTable 文件。MemTable 中的数据是以键值对的形式保存在内存中的。

2. **生成 SSTable 文件**
   LevelDB 会将 MemTable 中的数据按照 **字典序** 排序，然后将这些排序后的数据写入一个新的 SSTable 文件中。

3. **写入元数据**
   在写入完所有的键值对之后，LevelDB 会写入文件的尾部，包括 **索引** 和 **Bloom Filter** 等信息。

4. **写入磁盘**
   最终，生成的 SSTable 文件会被写入磁盘，成为数据库的一部分。

---

### 五、SSTable 和 LevelDB 层次存储的关系

LevelDB 使用 **多层存储（Leveling）** 机制来管理数据。SSTable 被分布在不同的层次中：

* **Level 0（L0）**：这是 LevelDB 中的第一层存储，SSTable 数据会在 MemTable 刷写时被写入到 Level 0。Level 0 中的数据块没有经过合并，因此可能存在很多重复数据。
* **Level 1 及以上（L1~L6）**：Level 1 及以上层次的数据是经过 **Compaction（压缩）** 处理后的数据。LevelDB 会定期对 Level 0 中的数据进行压缩操作，将数据移到更高的层级，以减少重复数据和优化查询性能。

### 压缩过程的工作原理：

1. **压缩**：当 Level 0 中的数据达到一定的阈值时，LevelDB 会将 Level 0 中的数据进行压缩，并将其移到 Level 1。这个过程会根据键的顺序合并多个 SSTable 文件，去除重复的数据。
2. **多层级存储**：通过将数据分布到多个层级中，LevelDB 能够保持查询效率，同时减少磁盘空间的浪费。

---

### 六、SSTable 的优缺点

#### 优点：

* **顺序存储，读性能高**：SSTable 文件内部数据是按键的字典序排列的，因此非常适合做顺序读取，这样可以最大化磁盘的读取性能。
* **可以进行高效的压缩**：由于数据已经是有序的，LevelDB 可以利用压缩算法（如 Snappy）对 SSTable 文件进行高效的压缩。
* **支持并发读写**：由于 MemTable 和 SSTable 是分离的，LevelDB 可以并发进行读和写操作。

#### 缺点：

* **读放大（Read Amplification）**：由于数据分布在多个层次的 SSTable 文件中，在查找一个键值对时，LevelDB 可能需要读取多个文件，导致读放大。
* **写放大（Write Amplification）**：由于 LevelDB 定期对 SSTable 文件进行压缩操作，合并过程中可能会导致数据重复写入，产生写放大。

---

### 七、总结

SSTable 是 LevelDB 存储数据的核心结构，负责将数据持久化到磁盘并支持高效的查询。它通过以下几个方式优化了 LevelDB 的性能：

* **有序存储**：SSTable 文件中的键值对按字典序排列，便于高效查询。
* **块结构**：SSTable 文件通过块存储数据，每个块是一个逻辑单位，便于读取和压缩。
* **Bloom Filter**：使用 Bloom Filter 加速键查找。
* **层级存储**：LevelDB 采用多层次存储机制，降低了读放大和写放大的影响。
`BlockBuilder` 类是 LevelDB 中的一个重要组件，它负责构建数据块（**Data Block**）。`BlockBuilder` 主要用于将一个或多个键值对按字典顺序打包到一个数据块中，并最终生成一个可以存储在 SSTable 文件中的块。

### 为什么需要 `BlockBuilder`？

在 LevelDB 中，数据会分散存储在多个 **SSTable 文件** 中，每个 SSTable 文件包含多个数据块（block）。每个数据块存储一部分键值对，它们是按照键的字典顺序排列的。

**`BlockBuilder` 的作用就是：**

* 将一系列键值对打包成一个数据块。
* 确保数据块中的键值对按照字典顺序存储。
* 计算并添加必要的元数据（比如键值对的大小、偏移量等）。

### `BlockBuilder` 的基本结构和功能

通常，在 LevelDB 中，`BlockBuilder` 会用来构建一个或多个数据块，这些数据块最终会被写入到 SSTable 文件中。`BlockBuilder` 负责以下几项任务：

* **打包键值对**：将给定的键值对按顺序放入数据块。
* **校验和计算**：每个数据块会生成一个 CRC 校验和，确保数据的完整性。
* **控制数据块大小**：避免数据块过大，保持文件的合理大小。

### 1. `BlockBuilder` 的接口与构造函数

在 LevelDB 中，`BlockBuilder` 通常有以下几个重要接口：

#### 构造函数

```cpp
BlockBuilder::BlockBuilder();
```

* 这个构造函数会创建一个 `BlockBuilder` 实例，它初始化了所有内部数据结构，准备开始构建数据块。

#### `Add` 方法

```cpp
void BlockBuilder::Add(const Slice& key, const Slice& value);
```

* `Add` 方法用于将一个键值对（`key`, `value`）加入到数据块中。
* 每个键值对会被**字典序**排列，确保数据块内部是有序的。

#### `Finish` 方法

```cpp
Slice BlockBuilder::Finish();
```

* `Finish` 方法用于完成数据块的构建。
* 调用此方法后，`BlockBuilder` 会生成一个完整的数据块（`Slice`），这个数据块可以写入到 SSTable 文件中。
* 此方法还会返回一个 `Slice`，表示这个数据块的内存视图。

#### `Reset` 方法

```cpp
void BlockBuilder::Reset();
```

* `Reset` 方法会清空当前的构建状态，重新开始构建新的数据块。

### 2. `BlockBuilder` 的实现

`BlockBuilder` 的实现过程是顺序的，它首先构建一个大的缓冲区来存储数据块，然后按顺序将键值对添加进去。它还会维护一个内部的**指针**，来追踪当前数据块的构建进度。

这里是 `BlockBuilder` 的一个简化版本：

```cpp
class BlockBuilder {
 public:
  BlockBuilder() {
    buffer_.clear();
    restart_count_ = 0;
    last_key_.clear();
  }

  // 将键值对添加到数据块中
  void Add(const Slice& key, const Slice& value) {
    assert(key.compare(last_key_) > 0);  // 确保是字典序
    last_key_ = key;

    // 追加 key 和 value 到 buffer
    buffer_.append(key.data(), key.size());
    buffer_.append(value.data(), value.size());

    // 每 1000 个键值对插入一个 restart point（可以跳过的地方，优化性能）
    if (++restart_count_ == kMaxRestarts) {
      restart_count_ = 0;
      // 记录新的 restart point
    }
  }

  // 完成数据块的构建
  Slice Finish() {
    // 添加 block 的结尾数据，像 CRC 校验和
    // 返回构建好的数据块
    return Slice(buffer_);
  }

  void Reset() {
    buffer_.clear();
    restart_count_ = 0;
    last_key_.clear();
  }

 private:
  std::string buffer_;          // 用于存储数据块内容的缓冲区
  int restart_count_;           // 用于记录 restart point 的计数器
  Slice last_key_;              // 记录上一个键
  static const int kMaxRestarts = 100;  // 控制 restart point 的数量
};
```

#### 主要构成：

1. **`buffer_`**：用于存储数据块的内存区域。
2. **`restart_count_`**：用于控制 restart points 的数量。`restart point` 是一个特殊的索引位置，允许跳过前面的一部分数据块。
3. **`last_key_`**：记录最后一个键，用于保证每个添加的键是按照字典序排列的。

### 3. 数据块的构建和优化

在 LevelDB 中，`BlockBuilder` 采用的优化机制主要包括：

* **Restart Points（重启点）**：

  * `restart_point` 是指在数据块中记录某个键的位置，以便在读取时跳过某些键的比较，减少比较的次数，提升查询效率。每 `kMaxRestarts` 个键值对就会插入一个 restart point。

* **字典序保证**：

  * 在向数据块中添加每个键值对时，`BlockBuilder` 确保这些键是按照字典序排列的。`Add` 方法中通过 `last_key_` 确保这一点。如果新加的键比上一个键小，`BlockBuilder` 会产生一个错误。

* **内存管理**：

  * `BlockBuilder` 在内存中构建数据块，因此它非常高效。在数据块构建完成后，通过 `Finish` 方法将内存中的数据块转化为一个 `Slice`，它就是最终可以写入磁盘的部分。

### 4. 为什么 `BlockBuilder` 这么重要？

`BlockBuilder` 的主要优势在于：

* **高效的内存管理**：通过构建数据块的方式，LevelDB 能够将大量的数据以最小的内存开销存储在内存中，并且避免了频繁的内存分配。
* **按字典序排序**：由于 SSTable 内部要求数据按字典序排列，`BlockBuilder` 保证了插入的数据块中的键是按字典序排列的，从而避免了在写入磁盘时需要进行排序。
* **数据块压缩**：`BlockBuilder` 在完成数据块后可以进行压缩（例如使用 Snappy），进一步减小存储空间，提高磁盘空间的利用率。
* **重启点优化**：通过使用 `restart point`，LevelDB 可以减少读取数据时的比较次数，优化查询性能。

---

### 总结

`BlockBuilder` 类在 LevelDB 中起到了重要的作用，它负责高效地构建 SSTable 文件中的数据块。通过按字典序插入键值对、使用 restart points、控制内存使用等优化策略，`BlockBuilder` 确保了数据写入磁盘时的高效性和查询时的快速响应。

它是构建 LevelDB 的持久化数据存储（SSTable）过程中的一个关键工具。如果你想更深入了解 LevelDB 的底层存储实现，`BlockBuilder` 是必须要理解的一个类。
`TableBuilder` 是 LevelDB 中用于构建 **SSTable 文件** 的类，SSTable 文件是 LevelDB 数据存储的核心文件格式。`TableBuilder` 主要负责将一组有序的键值对写入一个新的 SSTable 文件，它将键值对分成多个数据块（**Data Blocks**），并在文件尾部添加索引、过滤器等元数据。

### **`TableBuilder` 的主要任务**

1. **将数据按照字典顺序拆分到多个数据块**：`TableBuilder` 负责将键值对写入多个数据块，每个数据块包含一部分有序的键值对。多个数据块组合在一起构成一个 SSTable 文件。

2. **创建并管理文件尾部（Footer）**：SSTable 文件的尾部包含必要的元数据，例如索引（index）、过滤器（Bloom Filter）等，这些信息用于优化查找性能。`TableBuilder` 会在写入完所有数据块之后，将这些元数据追加到文件的尾部。

3. **管理和优化内存使用**：为了提高性能，`TableBuilder` 会分配一个内存缓冲区（Buffer）来存储当前的数据块内容。当数据块构建完成后，它会将这些数据写入磁盘。

4. **创建索引和过滤器**：在构建数据块时，`TableBuilder` 还会构建一个索引（Index Block），帮助快速定位每个键的所在位置，以及一个 **Bloom Filter**，用于快速判断一个键是否存在于 SSTable 中。

---

### **`TableBuilder` 主要接口**

1. **构造函数**：`TableBuilder` 的构造函数用于初始化和设置 SSTable 文件的相关参数。

```cpp
class TableBuilder {
 public:
  TableBuilder(const Options& options, WritableFile* file);
  ~TableBuilder();
```

* **参数**：

  * `options`：LevelDB 的配置选项，包含了创建 SSTable 时的各种参数，如 `block_size`、`compression` 等。
  * `file`：要写入数据的目标文件。

2. **`Add` 方法**：向当前 SSTable 文件中添加键值对。

```cpp
void TableBuilder::Add(const Slice& key, const Slice& value);
```

* **功能**：将一个新的键值对（`key`, `value`）添加到当前的数据块中。`key` 和 `value` 会按字典序排序，并被打包成一个数据块。

3. **`Finish` 方法**：完成数据块的构建，返回一个 `Slice`，表示整个 SSTable 文件的数据。

```cpp
Status TableBuilder::Finish();
```

* **功能**：调用此方法会关闭文件，并将数据写入磁盘，同时将索引和过滤器等元数据写入文件的尾部。完成构建之后，返回一个 `Status` 对象，表示操作是否成功。

4. **`Reset` 方法**：重置 `TableBuilder`，以便开始构建新的 SSTable。

```cpp
void TableBuilder::Reset();
```

* **功能**：清空内部缓冲区，准备开始构建新的 SSTable。

---

### **`TableBuilder` 内部实现**

`TableBuilder` 的内部工作流是将一个或多个 **MemTable** 中的有序键值对写入磁盘文件，并生成一个有效的 SSTable 文件。下面是 `TableBuilder` 工作的详细步骤：

#### 1. **初始化**

在 `TableBuilder` 构造函数中，它会初始化一系列的成员变量，并准备好构建一个新的 SSTable 文件。

* `block_size_`：每个数据块的大小。
* `pending_data_`：用于存储键值对的临时缓冲区。
* `index_block_`：存储索引数据。
* `footer_`：存储文件尾部的元数据（包括索引、过滤器等）。

#### 2. **添加键值对（`Add` 方法）**

`Add` 方法是 `TableBuilder` 的核心之一。它的工作就是将键值对添加到当前的数据块，并根据需要进行数据块的切分。

* 在添加每个键值对时，`TableBuilder` 会检查当前数据块是否已满。
* 如果数据块已满，`TableBuilder` 会将其写入文件，并开始构建新的数据块。
* 如果没有满，它会继续将键值对添加到当前数据块。

```cpp
void TableBuilder::Add(const Slice& key, const Slice& value) {
  // 如果当前数据块已满，写入当前数据块
  if (block_builder_.CurrentSizeEstimate() >= options_.block_size) {
    WriteBlockToFile();
  }
  // 将键值对添加到当前数据块
  block_builder_.Add(key, value);
}
```

#### 3. **生成数据块**

每当数据块大小达到 `block_size_` 限制时，`TableBuilder` 会通过 `block_builder_` 将数据块写入文件。

```cpp
void TableBuilder::WriteBlockToFile() {
  // 获取当前数据块
  Slice block_data = block_builder_.Finish();
  // 将数据块写入文件
  file_->Append(block_data);
  // 清空数据块
  block_builder_.Reset();
}
```

#### 4. **添加索引和过滤器**

`TableBuilder` 还会在数据块完成后，添加 **索引** 和 **Bloom Filter** 到文件中：

* **索引**：索引记录了每个数据块的最小和最大键，以及该块的偏移量，帮助快速定位某个键的存储位置。
* **Bloom Filter**：用于快速判断某个键是否存在于当前 SSTable 中。如果某个键不在 Bloom Filter 中，LevelDB 可以跳过当前 SSTable 文件，避免不必要的磁盘 I/O。

```cpp
void TableBuilder::AddIndexAndFooter() {
  // 添加索引
  index_block_ = ...;  // 构建索引数据块
  // 添加 Bloom Filter
  bloom_filter_ = ...; // 构建 Bloom Filter
  // 写入文件尾部（Footer）
  footer_ = ...;
  file_->Append(index_block_);
  file_->Append(bloom_filter_);
  file_->Append(footer_);
}
```

#### 5. **完成构建（`Finish` 方法）**

当所有的键值对都写入数据块后，`Finish` 方法会进行最后的文件处理工作：

* 完成所有数据块的写入。
* 将索引、过滤器、文件尾部的元数据写入文件。
* 关闭文件。

```cpp
Status TableBuilder::Finish() {
  // 将最后一个数据块写入文件
  WriteBlockToFile();
  // 添加索引和 Bloom Filter
  AddIndexAndFooter();
  // 写入文件结束标记
  return file_->Close();
}
```

---

### **TableBuilder 的优化**

1. **数据块压缩**：`TableBuilder` 使用压缩算法（如 Snappy）对数据块进行压缩，以减少磁盘空间的占用。

2. **增量写入**：每当数据块的大小超过 `block_size` 时，`TableBuilder` 会将数据块写入文件，这样可以避免将过多数据保存在内存中，控制内存使用。

3. **分层设计**：通过多个数据块和索引、过滤器等结构的组合，`TableBuilder` 实现了高效的查询和存储。

---

### **总结**

`TableBuilder` 是 LevelDB 中用于构建 **SSTable 文件** 的关键类。它的主要作用是将一组有序的键值对分割成多个数据块，并在文件尾部写入索引、过滤器等元数据，从而生成一个完整的 SSTable 文件。通过这种方式，LevelDB 能够高效地管理和存储大量的数据。

* `TableBuilder` 内部的工作流程包括：键值对的添加、数据块的构建、索引和过滤器的生成、文件尾部的写入等。
* 它采用了一些优化手段（如压缩、增量写入、索引等），提高了 LevelDB 的性能和存储效率。

---

## **1️⃣ 背景：SSTable 是什么？**

SSTable（Sorted String Table）是 LevelDB 持久化数据的核心文件，每个文件按键字典序排列，内部包含：

1. **数据块（Data Block）**：存储有序的键值对。
2. **索引块（Index Block）**：记录每个数据块的偏移和最大键。
3. **过滤器块（Filter Block，Bloom Filter）**：用于快速判断键是否存在。
4. **文件尾（Footer）**：记录 Index Block、Filter Block 的偏移和长度。

读取 SSTable 文件时，需要根据 **索引和 Bloom Filter** 快速定位到目标键所在的数据块，再从数据块中查找键值对。

---

## **2️⃣ SSTable 文件读取的入口**

LevelDB 中读取 SSTable 文件主要通过 **`Table` 类** 来实现。

* `Table` 封装了 SSTable 文件的所有操作，包括：

  * 打开文件
  * 读取 Footer
  * 读取 Index Block
  * 构建 Bloom Filter
  * 查找 key

当你调用 `DB::Get()` 时，如果 key 没在 MemTable 中，LevelDB 就会去 SSTable 查找。

---

## **3️⃣ SSTable 文件的读取流程**

假设我们要查找一个 key `"dog"`：

### **Step 0：打开 SSTable 文件**

```cpp
Table::Open(...)
```

* 打开文件并读取 **Footer**
* Footer 中记录了：

  * Index Block 的偏移和大小
  * Filter Block 的偏移和大小
* 初始化 Table 对象，将这些信息存储在内存中

---

### **Step 1：Bloom Filter 检查**

```cpp
filter->KeyMayMatch(key)
```

* Bloom Filter 可以告诉我们：

  * ✅ key 可能存在 → 继续查找
  * ❌ key 一定不存在 → 直接返回 NotFound
* 通过 Bloom Filter，可以避免不必要的磁盘 I/O

---

### **Step 2：在 Index Block 查找数据块**

Index Block 存储每个数据块的 **最大 key 和偏移位置**。
假设 Index Block 长这样：

```
banana -> block0_offset
dog    -> block1_offset
frog   -> block2_offset
hat    -> block3_offset
```

* 我们要查找 `"dog"`：

  * 二分查找 Index Block，找到第一个 >= `"dog"` 的 index key → `"dog"` 对应 block1
  * 得到 block1 的偏移量和大小
* ✅ 这样就知道 `"dog"` 可能在 block1 中

---

### **Step 3：读取 Data Block**

```cpp
BlockReader::Read(block_offset, block_size)
```

* 根据 index block 提供的偏移量，从文件中读取整个数据块到内存
* 数据块内部的键值对是按字典序排列的
* 数据块读取完成后，可以使用 BlockIterator 遍历键值对

---

### **Step 4：在 Data Block 中查找 key**

* Data Block 内部也有序，可以用二分查找快速找到 key
* 如果找到了 key → 返回对应 value
* 如果没找到 → 返回 NotFound

---

### **Step 5：缓存优化**

LevelDB 的 Table 还会用 **BlockCache** 来缓存 Data Block 和 Index Block：

* 避免重复读取磁盘，提高性能
* 对经常访问的 SSTable 数据块可以直接从缓存中拿

---

## **4️⃣ 图示总结**

下面用一个简单流程图表示整个 SSTable 查找过程：

```
DB::Get(key)
   |
   v
MemTable / Immutable MemTable
   |
   v
SSTable 文件（Table）
   |
   +--> Bloom Filter 判断 key 是否可能存在
           | yes
           v
       Index Block 二分查找 → 找到 Data Block
           |
           v
       Data Block 二分查找 → 找到 key?
           | yes → 返回 value
           | no  → NotFound
```

---

## **5️⃣ 读取过程核心优化**

1. **Bloom Filter** → 避免不必要的磁盘访问
2. **Index Block** → 精准定位 Data Block，减少 I/O
3. **Data Block 内二分查找** → 快速定位 key
4. **Block Cache** → 缓存 Data Block 和 Index Block，提高访问速度

---

## **6️⃣ 小结**

* SSTable 文件按 key 排序，查找 key 的效率很高
* 读取 SSTable 文件主要步骤：

  1. 打开文件并读取 Footer
  2. Bloom Filter 快速判断是否存在
  3. Index Block 定位 Data Block
  4. 读取 Data Block
  5. 在 Data Block 内查找 key
* 数据块缓存和 Bloom Filter 是 LevelDB 优化读取性能的关键

---



## **1️⃣ 背景**

在 LevelDB 中，SSTable 是有序的文件，每个文件由多个 **Data Block** 组成，每个 Data Block 内又是有序的键值对。

**要遍历 SSTable**，就是要顺序访问每个键值对；
**要获取键**，就是访问 Data Block 内的 key；
**要定位键**，就是找到某个 key 对应的 value 或确认它不存在。

这些操作主要通过 **Table 类** 和 **Iterator** 来完成。

---

## **2️⃣ SSTable 遍历流程**

### **2.1 TableIterator**

LevelDB 中的 `Table` 会提供一个 `NewIterator()` 方法，它返回一个 **TableIterator**（也叫 `BlockBasedTableIterator`）。

* `Iterator` 用于在整个 SSTable 文件内遍历键值对
* Iterator 提供的方法：

  * `Seek(key)`：定位到某个 key
  * `Next()`：移动到下一个 key
  * `Prev()`：移动到上一个 key
  * `Valid()`：判断当前是否有效
  * `key()` / `value()`：获取当前键值

### **2.2 遍历 Table 的步骤**

假设我们有一个 SSTable 文件：

```
Data Block 0: apple, banana
Data Block 1: cat, dog
Data Block 2: elephant, frog
```

* `Iterator::SeekToFirst()` → 定位到第一个键 `"apple"`
* `Iterator::Next()` → 移动到 `"banana"`
* 再 `Next()` → 跨到 Data Block 1 的 `"cat"`
* 再 `Next()` → `"dog"`，依次遍历所有键

**关键点**：当遍历到 Data Block 边界时，Iterator 会自动加载下一个 Data Block。

---

### **2.3 定位键（查找某个 key）**

当你想查找 `"dog"` 时，TableIterator 做了几件事：

1. **检查 Bloom Filter**：

   * 快速判断 key 是否可能存在
   * 如果返回 false → 不存在 → 直接结束

2. **在 Index Block 定位 Data Block**：

   * Index Block 记录每个数据块的最大 key 和偏移
   * 二分查找 index，找到 `"dog"` 所在的 Data Block（Data Block 1）

3. **读取 Data Block 并查找 key**：

   * Data Block 内的键是有序的
   * 二分查找 `"dog"` → 找到对应 value

### **2.4 获取键（key）**

* 如果遍历到某个位置，直接调用 `Iterator::key()`：

  ```cpp
  Slice key = it->key();
  Slice value = it->value();
  ```
* Iterator 内部维护当前 Data Block 和位置，返回的 key 是 Data Block 内的当前键。

---

## **3️⃣ 伪代码示例**

假设要遍历一个 SSTable，打印所有键：

```cpp
Iterator* it = table->NewIterator(ReadOptions());
for (it->SeekToFirst(); it->Valid(); it->Next()) {
    std::cout << it->key().ToString() << " -> " << it->value().ToString() << std::endl;
}
delete it;
```

如果要查找一个特定 key `"dog"`：

```cpp
Iterator* it = table->NewIterator(ReadOptions());
it->Seek("dog");
if (it->Valid() && it->key() == "dog") {
    std::cout << "Found: " << it->value().ToString() << std::endl;
} else {
    std::cout << "Not Found" << std::endl;
}
delete it;
```

---

## **4️⃣ 遍历和定位的优化**

1. **Data Block Cache**：

   * Table 会把 Data Block 缓存到内存中
   * 遍历或定位时如果 Data Block 在缓存中 → 避免磁盘 I/O

2. **Index Block + 二分查找**：

   * 定位 key 时，先用 Index Block 精准找到 Data Block
   * 再在 Data Block 内用二分查找 → 减少比较次数

3. **Bloom Filter**：

   * 过滤掉不存在的 key → 减少不必要的数据块访问

---

## **5️⃣ 图示理解**

假设 SSTable 文件有三个 Data Block：

```
Index Block:
banana -> Block0
dog    -> Block1
frog   -> Block2
```

遍历和定位过程：

```
遍历：
Iterator->SeekToFirst()
  -> Block0: apple -> banana
  -> Block1: cat -> dog
  -> Block2: elephant -> frog

定位 "dog"：
BloomFilter: mayContain("dog") -> yes
Index Block: dog <= dog? -> Block1
Read Data Block1
Binary search in Block1 -> find dog -> return value
```

---

### **6️⃣ 总结**

1. **SSTable 遍历**：

   * 使用 TableIterator（BlockBasedTableIterator）
   * 支持 `SeekToFirst()`, `Next()`, `Prev()` 遍历整个 SSTable
   * 自动跨 Data Block

2. **获取键**：

   * Iterator 内部维护 Data Block 和位置
   * `key()` / `value()` 获取当前键值

3. **定位键**：

   * 先用 Bloom Filter 判断
   * 再在 Index Block 查找 Data Block
   * 最后在 Data Block 内二分查找

4. **优化点**：

   * Data Block Cache
   * Bloom Filter
   * Index Block 二分查找

---
`TableCache` 是 LevelDB 中的一个重要组件，负责缓存和管理 SSTable 文件（具体来说是缓存 `Table` 对象）。在 LevelDB 中，SSTable 文件用于存储持久化的键值对数据，而 `TableCache` 作为缓存系统，旨在减少读取 SSTable 文件时的磁盘访问次数，从而提高性能。
---

## **1️⃣ `TableCache` 的作用**

`TableCache` 主要负责缓存已加载的 SSTable 文件，并根据需要从缓存中返回 `Table` 对象。具体功能包括：

1. **缓存已加载的 SSTable**：每当读取某个 SSTable 文件时，`TableCache` 会尝试首先从内存中获取 `Table` 对象，而不是每次都访问磁盘。

2. **减少磁盘 I/O**：通过缓存 `Table`，避免对相同的 SSTable 文件进行重复的磁盘读取，显著提高查询性能。

3. **管理缓存大小**：`TableCache` 会限制缓存的最大大小，当缓存达到限制时，最旧的条目会被淘汰（LRU 或类似策略）。

4. **支持缓存清理**：当 SSTable 被删除或压缩时，`TableCache` 会自动清理不再需要的缓存。

---

## **2️⃣ `TableCache` 的结构和实现**

### **2.1 主要成员变量**

如果你有兴趣，我可以为你提供更多关于 `TableCache` 设计和优化方面的细节，或者帮助你理解 `TableCache` 如何与其他组件协同工作，提升查询性能。

`TableCache` 的核心成员包括：

* **`cache_`**：存储已加载的 `Table` 对象的哈希表。
* **`options_`**：缓存的配置选项，包含缓存的最大大小等。
* **`env_`**：环境（`Env`）对象，用于访问磁盘等操作。
* **`mutex_`**：用于线程安全，确保多线程环境下对缓存的操作不会出现竞争条件。

### **2.2 主要函数**

下面是 `TableCache` 中的关键函数和操作流程：

#### **`FindTable()`**

该方法用于查找缓存中是否已有某个 SSTable 文件的 `Table` 对象。如果缓存中有，它会直接返回缓存的 `Table`，否则会从磁盘加载。

```cpp
Status TableCache::FindTable(const uint64_t file_number, const uint64_t file_size, Table** table) {
  // 先检查缓存中是否有该 Table 对象
  {
    MutexLock l(&mutex_);
    auto it = cache_.find(file_number);
    if (it != cache_.end()) {
      // 找到缓存中的 Table，直接返回
      *table = it->second.get();
      return Status::OK();
    }
  }

  // 如果缓存中没有，打开文件并加载 Table 对象
  std::string filename = Env::Default()->GetTableFileName(file_number);
  std::unique_ptr<Table> new_table;
  Status s = Table::Open(options_, env_, filename, file_size, &new_table);
  if (s.ok()) {
    MutexLock l(&mutex_);
    cache_[file_number] = std::move(new_table); // 缓存该 Table
    *table = cache_[file_number].get();
  }
  return s;
}
```

* **流程**：

  1. 首先检查缓存中是否已经有该文件的 `Table` 对象。
  2. 如果有，直接返回。
  3. 如果没有，加载文件并创建新的 `Table` 对象。
  4. 创建完之后，缓存该 `Table` 对象。

#### **`Evict()`**

当缓存中的 `Table` 数量达到限制时，`TableCache` 会移除最旧的 `Table` 对象，这种做法通常采用 **LRU（Least Recently Used）** 策略。

```cpp
void TableCache::Evict() {
  // 清理缓存中的最旧 Table
  if (cache_.size() > options_.max_cache_size) {
    // 获取并移除最老的缓存项
    auto it = cache_.begin();
    cache_.erase(it);
  }
}
```

* **流程**：

  1. 当缓存大小超过最大限制时，移除最旧的 `Table`。
  2. 清理掉那些不再需要的缓存，释放内存。

#### **`Prune()`**

当一些 SSTable 文件被删除或压缩时，`TableCache` 会清除缓存中与之相关的条目。这个过程通过调用 `Prune()` 方法实现：

```cpp
void TableCache::Prune(const std::set<uint64_t>& live_files) {
  MutexLock l(&mutex_);
  // 清理缓存中不再需要的 Table
  for (auto it = cache_.begin(); it != cache_.end();) {
    if (live_files.find(it->first) == live_files.end()) {
      it = cache_.erase(it); // 删除不再需要的 Table
    } else {
      ++it;
    }
  }
}
```

* **流程**：

  1. 清理缓存中已删除的或者不再需要的 SSTable 文件。
  2. 只保留活跃的 SSTable 文件。

---

## **3️⃣ `TableCache` 的使用场景**

### **3.1 查询过程**

当进行查询（如 `DB::Get()`）时，`TableCache` 会协助快速加载已经缓存的 `Table` 对象：

1. **查找缓存**：首先 `TableCache` 会检查缓存中是否已加载该 SSTable 文件的 `Table`。
2. **文件未缓存**：如果没有缓存，`TableCache` 会从磁盘加载该文件并创建 `Table` 对象，然后缓存该对象。
3. **返回 Table**：返回加载好的 `Table` 对象，后续查询可以通过 `Table` 对象内部的 `Iterator` 来遍历和查找数据。

### **3.2 缓存和内存管理**

`TableCache` 的一个重要目的就是控制内存的使用，避免缓存过多的 `Table` 对象占用太多内存。通过设置 `max_cache_size`，它可以控制缓存的大小，并且通过 **LRU 策略**和 **缓存淘汰**来确保内存使用的合理性。

---

## **4️⃣ `TableCache` 的优化**

### **4.1 使用 `LRU` 缓存策略**

`TableCache` 采用 **LRU（Least Recently Used）** 策略来管理缓存。这样可以确保最常访问的 `Table` 文件保持在缓存中，而最不常用的文件会被淘汰。这有助于提高访问频繁数据的性能。

### **4.2 `Table` 对象的懒加载**

`TableCache` 会对 `Table` 对象进行懒加载，即只有在真正需要的时候才会去打开并加载 SSTable 文件。这样可以避免不必要的文件读取，节省 I/O 操作。

### **4.3 使用内存池（Memory Pool）**

LevelDB 通过内存池（如 `Arena`）来管理缓存和其他内存资源，这有助于减少内存碎片并提高性能。

---

## **5️⃣ 总结**

`TableCache` 是 LevelDB 中用于缓存 SSTable 文件的关键组件，它可以显著提高查询效率，减少磁盘 I/O。主要功能包括：

* **缓存 Table 对象**：减少磁盘访问。
* **LRU 缓存策略**：控制缓存大小，移除最不常用的 Table。
* **缓存清理**：及时清除不再需要的缓存内容。
* **懒加载**：只有在需要时才加载 SSTable 文件。

通过这些机制，`TableCache` 可以有效地优化 LevelDB 的性能，减少重复读取磁盘的次数，提升系统的响应速度。

---
