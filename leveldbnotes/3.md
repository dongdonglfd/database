>FilterPolicy&Bloom

>FilterBlockBuilder

>文件组织和管理

>Status
---

# 一、先说人话：FilterPolicy 是干嘛的？

一句话版本：

> **FilterPolicy 定义“如何用一小块内存，快速判断一个 key *肯定不在* 这个 SSTable 里”**

注意关键词：
👉 **肯定不在**（false 一定准确）
👉 **可能在**（true 只是“有可能”）

它的主要目标是：

* ❌ **减少无意义的 SSTable 读**
* ❌ **避免读 index block / data block**
* ✅ **用极小代价挡住大量 NotFound 查询**

---

# 二、Bloom Filter 是什么？（直觉版）

## 1️⃣ 不用 Bloom 会发生什么？

你查一个 key：

```
MemTable 没有
→ Level-0 的 10 个 SSTable
→ Level-1 的 10 个 SSTable
→ Level-2 的 10 个 SSTable
```

如果 key 根本不存在：

* 每个 SSTable 都要：

  * 读 index
  * 读 data block
    💥 IO 爆炸

---

## 2️⃣ Bloom Filter 的核心思想

> 用 **多个 hash 函数 + bit 数组**
> 快速回答一个问题：
> **“这个 key 有没有可能在这里？”**

回答只有两种：

| Bloom 返回 | 真实含义             |
| -------- | ---------------- |
| false    | **一定不在**（100% 准） |
| true     | **可能在**（允许误判）    |

👉 **宁可多查一点，不允许漏数据**

---

## 3️⃣ 一个超具体的 Bloom 例子

### 假设：

* bit array 长度 = 10 bits
* 2 个 hash 函数

插入 key `"dog"`：

```
hash1("dog") % 10 = 3
hash2("dog") % 10 = 7
```

把 bit[3], bit[7] 置为 1：

```
index: 0 1 2 3 4 5 6 7 8 9
bits:  0 0 0 1 0 0 0 1 0 0
```

---

### 查询 `"cat"`

```
hash1("cat") % 10 = 3
hash2("cat") % 10 = 5
```

bit[5] = 0 ❌
→ **一定不在**

---

### 查询 `"pig"`

```
hash1("pig") % 10 = 3
hash2("pig") % 10 = 7
```

两个 bit 都是 1
→ **可能在（误判）**

👉 就算误判，也只是多做一次查找，不会丢数据

---

# 三、FilterPolicy 在 LevelDB 中的角色

`FilterPolicy` 是一个**接口**（策略模式）：

```cpp
class FilterPolicy {
 public:
  virtual const char* Name() const = 0;
  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const = 0;
  virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const = 0;
};
```

### 各方法干啥？

| 方法           | 作用                      |
| ------------ | ----------------------- |
| Name         | 标识 filter 类型            |
| CreateFilter | **写 SSTable 时构建 Bloom** |
| KeyMayMatch  | **读 SSTable 时查询 Bloom** |

LevelDB 默认实现：

```cpp
BloomFilterPolicy
```

---

# 四、Bloom Filter 在 SSTable 写入时怎么建？

## 1️⃣ 写 SSTable 时的流程

当 `TableBuilder` 在写 SSTable：

```text
Add(key1)
Add(key2)
Add(key3)
...
Finish()
```

内部会：

1. 收集 **所有 key**
2. 调用：

```cpp
filter_policy->CreateFilter(keys, n, &filter_data)
```

3. 把生成的 filter 写成一个 **Filter Block**

---

## 2️⃣ Filter Block 并不是“每个 SSTable 一个 Bloom”

⚠️ 重要细节：

> **LevelDB 的 Bloom 是“按 data block 分组”的**

### Filter Block 结构：

```
| filter for block 0 |
| filter for block 1 |
| filter for block 2 |
| ...                |
| offset array       |
```

也就是说：

* **每 N 个 data block 共用一个 Bloom**
* 默认 N = 2KB 的文件区间

👉 这样可以做到：

* Bloom 更小
* 查找更精准

---

# 五、读 SSTable 时 Bloom 是怎么用的？

当你 `DB::Get("dog")`：

## Step 1：先用 Filter

```cpp
if (!filter->KeyMayMatch(key, filter_block)) {
    // 一定不在这个 SSTable
    return NotFound;
}
```

⚡ **这里连 index block 都不读**

---

## Step 2：Bloom 通过 → 才继续

```text
Bloom: maybe
↓
Index Block
↓
Data Block
↓
Binary Search
```

👉 Bloom 的目标不是“帮你找”，
👉 而是“**帮你尽早放弃**”

---

# 六、FilterPolicy + TableCache + SSTable 的协作关系

你可以把它们理解成一层一层的“门禁”：

```
MemTable
  ↓
Bloom Filter        ← 90% NotFound 在这被挡掉
  ↓
Index Block
  ↓
Data Block
```

Bloom 是**最便宜的一层**：

* 纯内存
* 无 IO
* O(1)

---

# 七、关键参数：bits_per_key

```cpp
NewBloomFilterPolicy(int bits_per_key)
```

### 常见值：

| bits_per_key | 误判率   |
| ------------ | ----- |
| 4            | ~10%  |
| 8            | ~2%   |
| 10           | ~1%   |
| 16           | ~0.1% |

LevelDB 默认：**10 bits/key**

### 权衡关系：

* bits ↑ → Bloom 更大 → 内存多
* bits ↓ → 误判率高 → 多读磁盘

---

# 八、几个常见误区（非常重要）

### ❌ Bloom 能告诉你 key 在哪里？

不能
👉 它只回答 **“可能在 / 一定不在”**

---

### ❌ Bloom 能替代 index？

不能
👉 index 负责 **定位 block**

---

### ❌ Bloom 会漏数据？

不会
👉 false negative 在 Bloom 中是**不允许的**

---

# 九、一句话终极总结（建议背下来）

> **FilterPolicy 定义规则，Bloom Filter 执行规则**
>
> **Bloom 的唯一使命：
> 用最小的成本，尽早否定“不可能存在”的 SSTable**

---
好问题，这个类**正好把 Bloom Filter + Filter Block 串起来**，是你前面所有疑问的“落地实现”。
我用**通俗 + 源码思维**来讲，帮你建立**能自己看源码的理解模型**。

---

## 一句话先给你结论

**`FilterBlockBuilder` 的职责只有一个：**

> **在构建 SSTable 时，收集每个 Data Block 的 key，生成对应的 Bloom Filter，并把它们按规则拼成一个 Filter Block。**

它是 **“Filter Block 的建造者”**。

---

## 一、它在整个 SSTable 构建流程里的位置

先把大图放在脑子里 👇

```
MemTable → TableBuilder
                |
                +-- Data Block Builder
                |
                +-- Index Block Builder
                |
                +-- FilterBlockBuilder  ←（你现在看的）
```

👉 **TableBuilder 是总包工头**
👉 **FilterBlockBuilder 是专门负责 Bloom Filter 的工人**

---

## 二、FilterBlockBuilder 要解决什么问题？

你前面已经理解了这个事实：

> 一个 SSTable 有很多 Data Block
> 每个 Data Block 都需要一个 Bloom Filter
> 所有 Bloom Filter 要拼成一个 Filter Block

那问题来了：

### 问题 1：

**怎么知道“当前 key 属于哪个 Bloom Filter”？**

### 问题 2：

**Bloom Filter 是什么时候生成的？**

### 问题 3：

**多个 Bloom Filter 在文件里怎么排布？**

👉 **这三个问题，全由 `FilterBlockBuilder` 解决。**

---

## 三、FilterBlockBuilder 的核心设计思想

### 核心思想一句话：

> **不是“一个 Data Block 一个 Bloom Filter”，
> 而是“每 N 字节数据，共享一个 Bloom Filter”**

在 LevelDB 里：

```cpp
// 默认：每 2KB 数据一个 Bloom Filter
static const size_t kFilterBase = 1 << 11;  // 2048 bytes
```

👉 这样做的好处：

* Bloom Filter 数量不会爆炸
* 查询仍然足够精确
* 空间和性能折中得很好

---

## 四、FilterBlockBuilder 的关键成员变量（概念版）

不用死看代码，我给你“翻译成人话”👇

```cpp
class FilterBlockBuilder {
 private:
  const FilterPolicy* policy_;     // Bloom Filter 的算法（哈希规则）
  std::string keys_;               // 当前 filter 的所有 key（拼在一起）
  std::vector<size_t> start_;      // 每个 key 在 keys_ 中的起始位置

  std::string result_;             // 最终 Filter Block 内容
  std::vector<uint32_t> filter_offsets_; // 每个 Bloom Filter 的起始偏移

  size_t filter_base_lg_;           // log2(2048)
};
```

### 你可以这样理解：

| 成员                | 人话解释                           |
| ----------------- | ------------------------------ |
| `policy_`         | Bloom Filter 的“配方”             |
| `keys_`           | 暂存当前这一批 key                    |
| `start_`          | 每个 key 在 `keys_` 里的位置          |
| `result_`         | 最终写进 SSTable 的 Filter Block    |
| `filter_offsets_` | 每个 Bloom Filter 在 result_ 里的位置 |
| `filter_base_lg_` | 控制多少字节生成一个 filter              |

---

## 五、核心接口逐个讲（非常重要）

### 1️⃣ `AddKey(const Slice& key)`

👉 **每写入一个 key，就调用一次**

发生在：

```
TableBuilder::Add()
  └── FilterBlockBuilder::AddKey(key)
```

它干的事非常简单：

```text
把 key 放进当前 Bloom Filter 的“候选池”
```

⚠️ 注意：

* **不会立刻生成 Bloom Filter**
* 只是先存起来

---

### 2️⃣ `StartBlock(uint64_t block_offset)`

这是整个类最容易“卡壳”的地方，我慢慢讲。

#### 它什么时候被调用？

**每次准备写一个新的 Data Block 之前**

```cpp
TableBuilder::Flush()
  └── filter_block->StartBlock(data_block_offset);
```

#### 它干了什么？

```text
根据当前 data block 的 offset
判断：是不是该生成一个新的 Bloom Filter 了？
```

### 核心逻辑（人话版）：

```cpp
filter_index = block_offset / 2048
```

* 如果 `filter_index` 变大了
* 说明数据已经跨过了新的 2KB 区间
* 👉 **该把之前收集的 key 做成 Bloom Filter 了**

于是它会调用：

```cpp
GenerateFilter();
```

---

### 3️⃣ `GenerateFilter()`

这是**真正生成 Bloom Filter 的地方** 🔥

它做了三步：

#### Step 1：整理 key 列表

```text
从 keys_ + start_ 中恢复出一个 Slice 数组
```

#### Step 2：调用 Bloom Filter 算法

```cpp
policy_->CreateFilter(keys, &result_);
```

👉 这一步：

* 计算 hash
* 设置 bit
* 生成 Bloom Filter 的 bit 数组

#### Step 3：记录偏移

```text
把当前 result_.size() 记录到 filter_offsets_
```

这样将来就能：

> “第 N 个 Bloom Filter 在文件的什么位置？”

---

### 4️⃣ `Finish()`

👉 **所有 Data Block 都写完之后调用**

它负责：

1. **补齐最后一个 Bloom Filter**
2. **写 offset 数组**
3. **写 filter_base_lg**
4. 返回完整 Filter Block

#### Filter Block 的最终布局：

```
| filter0 | filter1 | filter2 | ... |
| offsets (uint32[])            |
| offset_array_start (uint32)   |
| filter_base_lg (1 byte)       |
```

---

## 六、读取时是如何用到这些信息的？

你前面问过的，现在可以完整串起来了👇

### 读一个 key 时：

1. 已知 **Data Block offset**
2. 计算：

```
filter_index = block_offset >> filter_base_lg
```

3. 用 `filter_offsets_[i]` 定位 Bloom Filter
4. 调用：

```cpp
policy_->KeyMayMatch(key, filter_data)
```

* `false` → 这个 data block 一定不用读
* `true` → 可能存在，继续查

---

## 七、一张“脑内结构图”（强烈建议你记住）

```
SSTable
├── Data Block 0
├── Data Block 1
├── Data Block 2
├── ...
├── Filter Block
│   ├── Bloom Filter 0 (for blocks [0..x])
│   ├── Bloom Filter 1
│   ├── Bloom Filter 2
│   ├── offsets[]
│   └── base_lg
└── Footer
```

---

## 八、你现在应该具备的能力

到这一步，你已经可以：

✅ 看懂 `FilterBlockBuilder`
✅ 理解 Bloom Filter 和 Data Block 的对应关系
✅ 自己跟进 `TableBuilder` 的写入流程
✅ 理解 `FilterBlockReader::KeyMayMatch`

---

LevelDB 的文件组织和管理是非常精密的，它的设计目标是提供高效的磁盘存储，尤其是优化读写操作。在 LevelDB 中，文件被分为多个类型，并通过一系列数据结构进行管理。下面我将详细介绍 LevelDB 的文件组织、存储结构、以及文件管理策略。

---

## 一、LevelDB 的文件类型

LevelDB 将数据存储在以下几类文件中，每种文件的作用不同：

### 1. **SSTable 文件**

* **定义**：SSTable（Sorted String Table）文件是 LevelDB 存储数据的主要格式，它包含了键值对的数据，并且按照 key 的字典顺序排序。
* **作用**：所有的数据都会最终存储在 SSTable 文件中。数据写入 MemTable 后，定期会被**刷新**到磁盘，形成新的 SSTable 文件。
* **命名规则**：SSTable 文件的命名通常为 `00000X.sst`，其中 `X` 是一个递增的数字（表示文件的版本）。

### 2. **MemTable**

* **定义**：MemTable 是一个内存中的数据结构（通常是跳表或哈希表），它用来暂时存储数据库的写入操作。
* **作用**：所有的写入操作（包括插入和删除）首先会被写入 MemTable。当 MemTable 达到一定大小时，它会被“**刷新**”到磁盘，成为一个新的 SSTable 文件。
* **刷新机制**：MemTable 会定期被刷新到磁盘，形成新的 SSTable 文件。如果 MemTable 已满，它会被持久化到一个新的 SSTable 文件中，并被清空，准备接受新的写入。

### 3. **Write-Ahead Log (WAL)**

* **定义**：Write-Ahead Log（写前日志）是一个用于持久化未提交事务的数据结构。
* **作用**：所有的写操作首先会被记录在 WAL 文件中，确保在系统崩溃时可以恢复数据。写入操作先写入 WAL，再写入 MemTable。
* **命名规则**：WAL 文件的命名通常是 `LOG` 或 `LOG.X`，`X` 是递增的数字。

### 4. **Manifest 文件**

* **定义**：Manifest 文件记录了 LevelDB 中所有 SSTable 文件的元数据，包括版本信息。
* **作用**：Manifest 文件是 LevelDB 的元数据存储中心，用于跟踪每一层的文件和版本信息。它记录了所有 SSTable 文件的索引信息，以及某一时刻所有文件的状态。

### 5. **Current 文件**

* **定义**：Current 文件是一个简单的文本文件，它保存了当前正在使用的 Manifest 文件的名称。
* **作用**：LevelDB 通过读取 `CURRENT` 文件来确定使用哪个 Manifest 文件。当数据库重新启动时，`CURRENT` 文件告诉 LevelDB 该加载哪个版本的 Manifest 文件。

### 6. **DBLock 文件**

* **定义**：DBLock 文件用于防止多个进程同时访问数据库。
* **作用**：这是一个锁文件，防止其他进程在一个进程写入数据时修改数据库。它保证数据库的一致性。

---

## 二、LevelDB 文件的层次结构

LevelDB 的文件系统结构包括了多个 **层（Level）**，这些层用于组织和管理 SSTable 文件的分布。

### 1. **Level 0**

* **定义**：Level 0 是一个特殊的层，所有新写入的 SSTable 文件最初都会放入 Level 0。
* **特点**：

  * Level 0 中的文件没有按顺序排列，可能存在重复的键。
  * 数据非常“脏”，因为多个文件可能包含相同的 key。
  * 数据的合并操作会通过 **Compaction** 来完成。

### 2. **Level 1 到 Level N**

* **定义**：Level 1 到 Level N（通常最多有 7 层）是 LevelDB 用来存储已经经过整理的 SSTable 文件的层。
* **特点**：

  * **每个层都是排序的**，并且每个层的数据量相对均匀。
  * 每个层的数据文件的大小逐渐增大，Level 1 的文件较小，Level N 的文件较大。
  * 数据会随着时间的推移和合并操作在不同的层之间迁移，保持 SSTable 文件的高效存储和访问。

### **层的组织（LevelDB 中的数据层次）**

* **Level 0**：

  * 数据块随机分布，可能包含重复的键值对。
  * 需要经过 **Compaction** 操作，合并到更高层次。
* **Level 1 到 Level N**：

  * 每层的数据都是经过整理的，数据块大小不断增大。
  * 每个层的数据块不允许重叠（即每个 key 只出现一次）。

---

## 三、文件的管理和压缩（Compaction）

### **Compaction** 过程

LevelDB 在数据写入和查询过程中，随着时间的推移，Level 0 中会积累大量的 SSTable 文件。为了维持查询性能，LevelDB 定期执行 **Compaction** 操作，将数据从 Level 0 移动到更高的层（Level 1 到 Level N），并合并重复或过期的键值对。

#### **Compaction 操作分为两种：**

1. **Major Compaction**：

   * 将 Level 0 中的数据合并到更高的层。
   * 会对 SSTable 进行排序和去重，确保每个层的数据无重复且有序。
   * Major Compaction 是一个 **高成本操作**，通常在后台定期进行。

2. **Minor Compaction**：

   * 主要是在 Level 1 以上的层之间进行，目的是合并各个层中的小文件。
   * 这个操作可以减少磁盘 I/O，优化查询性能。

#### **Compaction 的流程**：

* **Level 0 到 Level 1**：Level 0 中的 SSTable 文件会被合并并移到 Level 1。
* **Level 1 到 Level 2**：Level 1 中的 SSTable 文件会被合并并移到 Level 2，依此类推。
* **合并的结果**：每个层的文件会被压缩成更大的文件，并且避免同一层中出现重复的键。

### **Compaction 的优势**：

* **减少磁盘碎片**：避免了大量的小文件，提升了磁盘的读取效率。
* **提升查询性能**：将多个 SSTable 文件合并为一个较大的文件，提高了查找速度。

---

## 四、LevelDB 的文件管理策略

LevelDB 中的文件管理有许多策略来提高性能和减少磁盘空间的浪费。以下是一些关键策略：

### 1. **Write-Ahead Log（WAL）**

* **作用**：保证数据库的持久性和事务一致性。在进行写操作时，首先会将数据写入 WAL 文件，再写入 MemTable。
* **WAL 的重要性**：

  * **数据恢复**：当数据库崩溃时，可以通过 WAL 恢复未写入磁盘的操作。
  * **事务一致性**：写入操作先记录到 WAL，确保即使系统崩溃，数据也不会丢失。

### 2. **延迟写入**

LevelDB 会将 MemTable 中的数据定期刷新到磁盘，每次刷新都会生成新的 SSTable 文件。通过延迟写入，LevelDB 能够将多个写操作合并，减少对磁盘的频繁写入，从而提高性能。

### 3. **压缩算法（Snappy）**

LevelDB 使用 **Snappy** 压缩算法来压缩存储的数据，以减少磁盘空间的占用，并提高磁盘 I/O 性能。每个 SSTable 文件在写入时会进行压缩，读取时解压。

---

## 总结

LevelDB 的文件管理非常精细，它通过不同类型的文件来组织数据和元数据，并使用高效的压缩、合并策略来保证性能。主要的文件类型包括 MemTable、WAL、SSTable、Manifest 等，每种文件都有其特定的用途和生命周期管理。通过层次化的存储（Level 0 到 Level N）和 Compaction 机制，LevelDB 能够高效地管理数据存储，提供快速的读写操作。

LevelDB 中的 **版本控制** 是数据库内部的一个非常重要的机制，它用来管理数据库中数据的变化，特别是在不同的 **SSTable 文件** 和 **MemTable** 之间的数据迁移、合并和更新。通过版本控制，LevelDB 能够确保在执行写入、读取和 Compaction 操作时，保持数据一致性、减少重复并提高查询效率。

### **一、版本控制的背景**

LevelDB 的版本控制的目标是管理 **数据的多版本**，让每次写入和读取都能够在不同的 **数据层级（Levels）** 和 **MemTable 状态** 中进行同步，避免不一致性。

#### **版本控制的核心挑战**：

1. **如何在数据不断更新的情况下维护一致性**。
2. **如何在有多层 SSTable 和 MemTable 时确保数据一致性**。
3. **如何避免读取到过时的数据**。

---

## 二、LevelDB 中的版本控制实现

在 LevelDB 中，**版本控制** 主要通过 `VersionSet` 和 `Version` 这两个类来实现。`VersionSet` 用来管理多个版本的 SSTable 文件，`Version` 则表示一个具体的数据库版本，包含了所有的数据层（从 Level 0 到 Level N）的信息。

### 1. **VersionSet 类**

`VersionSet` 是 LevelDB 中最核心的组件之一。它负责跟踪数据库的所有版本信息，特别是关于 SSTable 文件的变化。每次进行 **写操作** 或 **Compaction** 操作时，都会生成一个新的版本。

* **VersionSet 的作用**：

  * **维护每个层的文件列表**：Level 0 到 Level N 每一层的 SSTable 文件。
  * **版本快照管理**：用于保存数据库某个时刻的状态。
  * **Compaction 后的版本更新**：当执行 Compaction 时，新的 SSTable 会加入到 VersionSet 中，旧的 SSTable 会被清理。

#### **VersionSet 的主要成员变量**：

```cpp
class VersionSet {
 public:
  VersionSet(Env* env, const std::string& dbname, const Options& options);
  ~VersionSet();

  Status LogAndApply(VersionEdit* edit, SequenceNumber* seq);
  Status Get(const ReadOptions& options, const Slice& key, std::string* value);

  // 获取某个版本的信息
  Version* current() const { return current_; }

  // 其他成员变量用于存储数据库的元数据
  std::unique_ptr<Version> current_;   // 当前的 Version
  std::vector<std::unique_ptr<Version>> versions_;  // 所有版本
  VersionEdit pending_edit_;  // 等待应用的变更记录
};
```

`VersionSet` 会在执行 **写操作**（如插入数据、删除数据）时，更新数据库的 **版本信息**，并且在 **Compaction** 操作时，更新对应的 **Level** 中的文件。

---

### 2. **Version 类**

`Version` 类代表了数据库的一个具体版本，包含了一个 Level 中的所有 SSTable 文件及其索引。它用于存储和管理 **LevelDB 各层的文件结构** 和 **版本元数据**，并在执行 Compaction 时，帮助决定哪些文件需要被保留、删除或合并。

#### **Version 的主要成员变量**：

```cpp
class Version {
 public:
  Version();
  ~Version();

  // 用于管理每个层次的文件
  std::vector<FileMetaData*> files[kNumLevels];

  // 版本信息
  SequenceNumber last_sequence_;
  uint64_t timestamp_;

  // 用于获取当前版本下某个层次的数据
  const std::vector<FileMetaData*>& files_at(int level) const {
    return files[level];
  }
};
```

每个 `Version` 包含了 **每个 Level 的文件列表**，这些文件列表用于查询和更新数据。当进行 **Compaction** 时，`Version` 会通过对比不同版本的文件，选择需要合并、删除或保留的文件。

#### **Version 的作用**：

* **管理数据层级**：通过保存每个 Level 中的文件，确保数据层次的一致性。
* **维护文件元数据**：保存文件的大小、键范围等元数据，方便进行查询。
* **支持快速更新和查询**：通过维护一个最新的版本（`current_`），LevelDB 可以快速查询和应用更新。

---

### 3. **VersionEdit 类**

`VersionEdit` 代表对一个 `Version` 进行修改的编辑操作。每次进行写操作（如添加、删除或更新 SSTable 文件）时，都会生成一个 `VersionEdit` 对象，并将其应用到 `VersionSet` 中，更新数据库的状态。

#### **VersionEdit 的作用**：

* **记录变更**：记录哪些文件需要被添加、删除或更新。
* **版本应用**：通过 `VersionSet::LogAndApply` 方法，将 `VersionEdit` 的变更应用到当前版本中。

#### **VersionEdit 主要成员**：

```cpp
class VersionEdit {
 public:
  VersionEdit();

  // 添加、删除文件操作
  void AddFile(int level, uint64_t file_number, uint64_t file_size);
  void DeleteFile(int level, uint64_t file_number);

  // 修改版本的序列号等
  void SetPrevLogNumber(uint64_t prev_log_number);
  void SetLogNumber(uint64_t log_number);

  // 获取当前编辑操作的序列号
  SequenceNumber GetSequenceNumber() const;

 private:
  std::map<int, std::vector<FileMetaData>> added_files_;
  std::map<int, std::set<uint64_t>> deleted_files_;
};
```

#### **VersionEdit 的操作**：

* **AddFile**：将一个新的文件添加到某个层次。
* **DeleteFile**：删除某个层次的一个文件。
* **SetLogNumber**：设置日志文件号。
* **SetPrevLogNumber**：设置前一个日志文件号。

---

## 三、版本控制的应用场景

### 1. **Compaction 后的版本更新**

当执行 **Compaction** 操作时，LevelDB 会生成一个新的版本，包含合并后的 SSTable 文件。通过版本控制，LevelDB 能够确保合并后的文件在新版本中被正确添加，并将旧的无效文件标记为删除。

### 2. **数据恢复与回滚**

通过版本控制，LevelDB 可以根据不同的版本状态进行数据恢复。如果在操作过程中出现崩溃，LevelDB 可以从 WAL 文件恢复到最近的有效版本。每个 `Version` 都保存了 SSTable 文件的元数据，包括文件的创建时间、大小和内容范围，从而保证恢复的一致性。

### 3. **并发与快照支持**

LevelDB 使用版本控制支持快照（Snapshots）。每次创建快照时，都会保存当前 `Version` 的快照，确保读取时的一致性。在并发操作中，LevelDB 会保证每个操作都基于同一个版本进行，从而避免数据不一致。

---

## 四、总结

LevelDB 的 **版本控制** 是通过 `VersionSet`、`Version` 和 `VersionEdit` 等数据结构实现的，主要目的是为了管理数据库中多个层次的 SSTable 文件，确保数据的一致性和高效查询。版本控制通过以下方式进行工作：

* **`VersionSet`**：管理所有的数据库版本信息。
* **`Version`**：保存每个层次的 SSTable 文件的元数据。
* **`VersionEdit`**：记录对 `Version` 的变更操作，如添加、删除文件。

通过这种方式，LevelDB 可以高效地处理数据的更新、删除和查询，保证系统的高性能和数据一致性。

在 **LevelDB** 中，`Status` 是一个非常重要的类，用于表示和处理操作的执行结果，尤其是在文件 I/O、数据库操作、查询和其他可能出错的场景中，`Status` 提供了一种统一的错误处理机制。

### **1. `Status` 的基本作用**

`Status` 主要用于描述函数调用的 **返回状态**，它包含了函数执行时的 **成功或失败信息**。通过 `Status`，用户可以判断某个操作是否成功，或者遇到什么样的错误。

### **2. `Status` 的主要功能和方法**

`Status` 类有以下几个关键功能和方法：

#### **2.1 构造函数**

`Status` 类的构造函数主要用于初始化状态。默认情况下，`Status` 初始化为成功状态。

```cpp
Status::Status();  // 默认构造函数，表示成功
Status::Status(Code code, const Slice& msg);  // 构造函数，表示错误状态
```

* `Status()` 默认构造函数会生成一个成功状态。
* `Status(Code code, const Slice& msg)` 可以指定错误的类型和消息。

#### **2.2 错误码 (Code)**

`Status` 类使用 **Code** 枚举类型来描述错误的类型。常见的错误类型包括：

```cpp
enum Code {
    kOk = 0,      // 成功
    kNotFound = 1, // 键未找到
    kCorruption = 2, // 数据损坏
    kNotSupported = 3, // 不支持的操作
    kInvalidArgument = 4, // 无效的参数
    kIOError = 5,   // I/O 错误
    kMergeInProgress = 6, // 合并中
    kShutdownInProgress = 7, // 关闭中
    // 其他错误代码...
};
```

* **kOk** 表示操作成功。
* **kNotFound** 表示没有找到请求的键。
* **kCorruption** 表示数据库发生了损坏。
* **kInvalidArgument** 表示传入了无效的参数。
* **kIOError** 表示 I/O 错误。

#### **2.3 常用方法**

1. **`ok()`**：检查状态是否为成功。

   ```cpp
   bool ok() const;
   ```

   * 如果状态是 **`kOk`**，返回 `true`，表示操作成功。
   * 如果是其他错误码，返回 `false`。

2. **`IsNotFound()`**：检查状态是否为 "未找到" 错误。

   ```cpp
   bool IsNotFound() const;
   ```

   * 如果状态为 **`kNotFound`**，表示找不到对应的键。

3. **`ToString()`**：将状态转换为字符串，通常用于调试。

   ```cpp
   std::string ToString() const;
   ```

   * 将 `Status` 对象转化为可读的字符串，描述状态的代码和消息。

4. **`IsCorruption()`**：检查状态是否为数据损坏错误。

   ```cpp
   bool IsCorruption() const;
   ```

   * 如果状态为 **`kCorruption`**，表示数据库文件损坏。

5. **`status()`**：返回当前状态信息，通常用于调试。

---

### **3. 使用 `Status` 处理错误**

在 **LevelDB** 中，很多操作都会返回 `Status` 类型的结果，通过检查 `Status` 来判断操作是否成功，以及发生了什么错误。通常，`Status` 用于函数返回值，表示操作的成功或失败。

#### **3.1 检查操作结果**

例如，进行查询操作时：

```cpp
Status DB::Get(const ReadOptions& options, const Slice& key, std::string* value);
```

* 如果查询成功，`Status::ok()` 返回 `true`，并且 `value` 会存储对应的值。
* 如果查询失败（例如，键不存在），`Status::IsNotFound()` 返回 `true`，说明数据库中没有该键。

```cpp
std::string value;
Status s = db->Get(options, key, &value);

if (s.ok()) {
    // 成功，处理结果
    std::cout << "Found value: " << value << std::endl;
} else if (s.IsNotFound()) {
    // 键不存在
    std::cout << "Key not found." << std::endl;
} else {
    // 其他错误
    std::cout << "Error: " << s.ToString() << std::endl;
}
```

#### **3.2 错误处理**

在插入或删除数据时，如果发生错误，`Status` 对象也会返回错误信息。例如：

```cpp
Status DB::Put(const WriteOptions& options, const Slice& key, const Slice& value);
```

* 成功时，返回 `Status::ok()`，表示数据写入成功。
* 失败时（例如，参数错误、磁盘满了等），返回对应的错误状态。

```cpp
Status s = db->Put(write_options, key, value);
if (s.ok()) {
    std::cout << "Data inserted successfully." << std::endl;
} else {
    std::cout << "Failed to insert data: " << s.ToString() << std::endl;
}
```

#### **3.3 `Status` 和异常处理**

LevelDB 并不直接使用 C++ 异常来报告错误，而是通过 `Status` 对象来处理和传递错误信息。这种方式使得错误处理更加显式，并且避免了异常机制的开销。

---

### **4. `Status` 代码示例**

```cpp
// 使用 Status 检查数据库操作结果
Status status = db->Write(write_options, &batch);
if (!status.ok()) {
    // 如果操作失败，打印错误信息
    std::cerr << "Write failed: " << status.ToString() << std::endl;
} else {
    std::cout << "Write successful!" << std::endl;
}

// 查询一个键
std::string value;
Status status = db->Get(read_options, key, &value);
if (status.ok()) {
    std::cout << "Key found, value: " << value << std::endl;
} else {
    std::cerr << "Failed to retrieve key, error: " << status.ToString() << std::endl;
}
```

---

### **5. `Status` 的作用总结**

* **状态表示**：`Status` 用于表示和处理函数操作的返回状态，帮助开发者判断操作是否成功。
* **错误处理**：通过检查 `Status`，开发者可以知道数据库操作的具体错误（如键不存在、数据库损坏等），并做出相应的处理。
* **简化异常机制**：LevelDB 通过返回 `Status` 对象来避免使用异常，简化了错误处理逻辑，并且具有更高的性能。

