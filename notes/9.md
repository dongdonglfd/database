# 一、先搞清楚：这一讲在干嘛？

前面的课你学的是：

* 表怎么存（Heap / Page）
* 索引怎么查（B+Tree / Hash）
* 并发怎么保证结构不坏（Latch）

👉 **但现在的问题是：SQL 真正怎么“跑起来”？**

---

# 二、Query Plan 是什么？（执行计划）

## 1️⃣ SQL 不是直接执行的

数据库不会一句一句“解释 SQL”，而是：

```text
SQL
 ↓
解析（Parser）
 ↓
优化（Optimizer）
 ↓
Query Plan（执行计划）
 ↓
真正执行
```

---

## 2️⃣ Query Plan 是什么样？

* 是一棵 **树 / DAG**
* 每个节点是一个 **Operator（算子）**

### 例子

```sql
SELECT dept, COUNT(*)
FROM student
WHERE score > 60
GROUP BY dept
ORDER BY COUNT(*) DESC
LIMIT 3;
```

对应的计划（简化）：

```
Limit
  ↓
Sort
  ↓
Aggregate
  ↓
Filter
  ↓
Seq Scan
```

📌 **本讲重点：Sort 和 Aggregate 这两个算子怎么实现**

---

## 3️⃣ 磁盘型数据库的核心目标

> **尽量少 I/O，尽量顺序 I/O**

为什么？

* 顺序读磁盘：快
* 随机读磁盘：慢到爆

---

# 三、为什么 DBMS 一定要“排序”？

## 1️⃣ 关系模型没有“默认顺序”

表 ≠ Excel
表是 **无序集合**

所以：

* `ORDER BY` → 必须排序
* `GROUP BY` → 常常靠排序
* `DISTINCT` → 可以排序去重
* `JOIN` → Sort-Merge Join

---

## 2️⃣ 如果数据能放进内存

那就简单了：

* quicksort
* mergesort
* std::sort

👉 **但真实数据库：几 GB / TB**

---

# 四、Top-N Heap Sort（非常重要的优化）

## 场景

```sql
SELECT *
FROM orders
ORDER BY price DESC
LIMIT 10;
```

---

## 关键观察

> 我根本不关心后面的 9999990 行
> **只要前 10 个**

---

## 做法：优先队列（堆）

* 扫描表一次
* 维护一个 **大小为 N 的堆**
* 新元素：

  * 比堆顶好 → 放进去
  * 否则丢掉

👉 **时间 O(N log K)**
👉 **内存只要 K 条**

---

## WITH TIES

```sql
LIMIT 10 WITH TIES
```

意思是：

* 第 10 名有并列
* 并列的也要

👉 堆可以**动态扩展**

---

## 什么时候是理想情况？

* Top-N **完全放得进内存**
* 不需要外部排序

---

# 五、External Merge Sort（外部归并排序）【重头戏】

这是数据库排序的 **标准答案**。

---

## 核心思想（一句话）

> **内存放不下？
> 那就：分批排 → 写盘 → 再合并**

---

## 两个阶段

---

### 🔹 Phase 1：Sorting（生成初始 runs）

#### 做什么？

1. 一次读 **一小块数据（能放进内存）**
2. 在内存排序
3. 写回磁盘

每个排序后的块叫 **run**

---

### 🔹 Phase 2：Merge（归并 runs）

* 多个有序 run
* 合成更大的有序 run
* 一直合到只剩一个

---

## Early vs Late Materialization

### Early

* run 里存 **完整 tuple**
* 简单
* I/O 大

### Late

* run 里只存 **RID**
* 排完再回表
* I/O 小，但逻辑复杂

---

# 六、Two-Way Merge Sort（最基础版本）

## 内存限制：3 页

* 2 页输入
* 1 页输出

---

## 过程

1. Phase 1：

   * 每页单独排
   * 得到 N 个 run

2. Phase 2：

   * 两两合并
   * run 数量 /2

3. 重复，直到剩 1 个

---

## 成本怎么算？

* 总页数：N
* 需要：

  ```
  1 + ⌈log₂N⌉ 次扫描
  ```
* 每次扫描：

  * 读 N 页
  * 写 N 页

👉 **总 I/O = 2N × passes**

---

# 七、K-Way Merge Sort（通用版本，真实系统用的）

## 现在假设有 B 个 buffer page

---

### Phase 1（生成 runs）

* 一次读 **B 页**
* 排序
* 写回

👉 run 数量：

```
⌈N / B⌉
```

---

### Phase 2（归并）

* 每次最多合并 **B−1 个 run**
* 1 页做输出

---

## 需要多少趟？

```
1 + ⌈ log_{B−1} (⌈N / B⌉) ⌉
```

👉 内存越大，趟数越少
👉 趟数越少，I/O 越少

---

# 八、Double Buffering（双缓冲优化）

## 问题

* CPU 在等 I/O
* I/O 在等 CPU

---

## 思路

> **一边算，一边偷偷读下一批**

---

## 做法

* 两套 buffer
* 一套在 merge
* 一套在预读

需要多线程
有效 buffer 减半

---

# 九、排序中的比较优化

比较 key 本身也很贵。

---

## 1️⃣ Code Specialization（代码特化）

* 不用函数指针 comparator
* 编译期直接生成比较代码

👉 C++ template

---

## 2️⃣ Suffix Truncation（字符串前缀）

* 先比前几个字节
* 不同就结束
* 相同再全比

---

## 3️⃣ Key Normalization

* 把变长 key
* 编码成定长
* 保证顺序一致

---

# 十、能不能不用排序？用 B+Tree！

## 情况 1：**聚簇索引（Clustered Index）** ✅

* 数据本身按 key 排好
* 顺序扫叶子节点

👉 **比外排还快**
👉 **零计算**

---

## 情况 2：非聚簇索引 ❌

* 每个 RID 指向随机页
* 几乎全是随机 I/O

例外：Top-N，N 很小

---

# 十一、Aggregation（聚合）开始

聚合 = 多条 → 一条

```sql
COUNT
SUM
AVG
MIN
MAX
```

---

# 十二、Aggregation 的两大实现路线

## 1️⃣ 排序聚合

## 2️⃣ 哈希聚合

---

# 十三、排序聚合（Sort-Based Aggregation）

## 思路

1. 按 GROUP BY key 排序
2. 顺序扫描
3. 相同 key 累加

---

## 优点

* 输出 **天然有序**
* 易于实现

---

## 优化点

> **先过滤，再排序**

```sql
WHERE → GROUP BY → SORT
```

减少排序数据量

---

# 十四、哈希聚合（Hash Aggregation）

## 思路

* 用 hash 表
* key = GROUP BY key
* value = RunningValue

---

## 如果能放进内存（理想）

* 一次扫描
* 一次 hash
* 结束

👉 **比排序快**

---

# 十五、External Hash Aggregation（重点）

当 hash 表放不下内存。

---

## Phase 1：Partition（分区）

### 做什么？

* 用 hash 函数 h1
* 把数据分到 **B−1 个桶**
* 每个桶写磁盘

同一个 key → 一定进同一个桶

---

## Phase 2：ReHash（再哈希）

* 一次处理一个桶
* 读入内存
* 用 **另一个 hash h2**
* 做真正的聚合

---

## 为什么要 h1 ≠ h2？

* 避免坏分布
* 降低冲突

---

## 如果桶还是太大？

👉 **递归分区**

---

# 十六、RunningValue 是什么？

取决于聚合函数：

| 聚合      | RunningValue |
| ------- | ------------ |
| COUNT   | count        |
| SUM     | sum          |
| AVG     | (count, sum) |
| MIN/MAX | 当前最值         |

---

# 十七、排序聚合 vs 哈希聚合（怎么选）

| 情况     | 更好   |
| ------ | ---- |
| 需要排序输出 | 排序   |
| 数据已排序  | 排序   |
| 只关心结果  | 哈希   |
| 内存充足   | 哈希   |
| 内存紧张   | 排序更稳 |

实际系统会 **成本模型选择**

---

# 十八、整讲一句话总结

> **Sorting & Aggregation 的本质是：**
>
> * 内存不够 → 外部算法
> * 排序：I/O 稳定，但贵
> * 哈希：快，但怕爆内存
> * 一切围绕：**减少磁盘访问**

---


