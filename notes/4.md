# 一、整体背景：什么是 Disk-Oriented DBMS？
**Disk-Oriented 是什么意思？**

一句话：

数据库的“老家”在磁盘，不在内存

数据最终存在：

HDD

SSD

内存只是“临时工作区”

👉 这和 In-Memory DBMS（比如 Redis）是相反的。

 **为什么一定要搬来搬去？**

因为计算机的底层架构（冯·诺依曼架构）决定了：

CPU 只能操作内存里的数据

所以任何 DBMS：

想算数据

就必须先把数据
👉 从磁盘 → 内存

 **DBMS 的目标假象（非常重要）**

从 DBMS 的视角看，应该“感觉”整个数据库都在内存里

也就是说：

查询执行器

索引

算子

不关心数据从哪来

👉 只要给我一个内存指针就行

谁负责“偷偷搬数据”？

👇
Buffer Pool Manager

# 二、两个核心优化目标
**Spatial Control（空间控制）**

👉 数据在磁盘上“放哪”

目标：

经常一起用的 page

尽量放在磁盘上相邻的位置

好处：

顺序 I/O

更好 prefetch

更少寻道

**Temporal Control（时间控制）**

👉 什么时候把 page 读进来 / 写出去

目标：

尽量减少：

查询被 I/O 卡住

等磁盘的时间
# 三、Buffer Pool（缓冲池）——核心组件
 **Buffer Pool 是什么？**

一句话定义：

Buffer Pool = DBMS 自己管理的一大块内存缓存

它是：

内存

但不交给 OS

由 DBMS 完全控制

 **Buffer Pool 的结构**
基本组织方式

一整块内存

切成很多 固定大小的 Frame

每个 frame = 1 个 page
```c
Buffer Pool:
+-------+-------+-------+
|Frame0 |Frame1 |Frame2 |
+-------+-------+-------+
```
 **访问一个 page 的流程**

当 DBMS 要 page X：

查 page table

如果 page 已在内存：

直接用

如果不在：

找一个空 frame

从磁盘读 page

放进去

**Write-Back vs Write-Through（非常重要）**
DBMS 用的是：Write-Back Cache

什么意思？

修改 page

先不写磁盘

只标记为 dirty

等合适时机再写

优点：

少 I/O

合并多次修改

Write-Through（不用）

一改就写磁盘

I/O 爆炸

**Buffer Pool 用来干嘛？**

不仅仅是“表数据”：

表 & 索引页

排序 / Join 的中间结果

查询 cache

日志 buffer

⚠️ 有些结构：

可能只在内存

不一定落盘

 **Page Directory（磁盘上的）**

👉 page_id → 磁盘文件位置

必须在磁盘

DBMS 重启要靠它找数据

⚠️ 通常：

会在内存里缓存一份

因为每次访问 page 都要查

# 四、Buffer Pool 的元数据（重中之重）
**Page Table（内存中的）**

👉 page_id → frame_id

这是：

一个内存 hash 表

不落盘

Page Table 里每页还有：
① Dirty Flag（脏页标记）

被修改过？

是 → eviction 前必须写盘

② Pin / Reference Counter（钉住计数）

👉 表示：

有多少线程正在用这个 page

规则：

pin > 0
❌ 不能被淘汰

③ Access Tracking Info

谁在用

给 eviction 策略用

**Pin 的意义（一定要理解）**

 类比：

你正在看一本书

别人不能把它从你手里抢走

DBMS 中：

线程访问 page → pin++

用完 → pin--

⚠️ 如果：

Buffer Pool 满了

所有 page 都 pinned
👉 直接 OOM（out of memory）

**Page Table vs Page Directory**
| 对比  | Page Directory  | Page Table   |
| --- | --------------- | ------------ |
| 位置  | 磁盘              | 内存           |
| 作用  | page → 磁盘位置     | page → frame |
| 重启后 | 必须存在            | 重新建          |
| 谁用  | Storage Manager | Buffer Pool  |

# 五、Locks vs Latches
**Locks（锁）**
1.功能：

锁是高层次的同步机制，主要用于保护事务之间的操作，防止并发事务同时修改数据导致数据不一致。

2.作用：

逻辑级别的保护：数据库事务需要锁来保证不同事务对数据的访问互不干扰。

锁的目的是 保持一致性，即保护数据完整性。

举个例子：

你和我都想修改一个账户的余额。

为了防止你和我同时修改，锁住账户记录，确保只有我操作完后，才能由你进行操作。

3.特点：

事务级别：锁是围绕事务来保护的。

可回滚：如果事务回滚，锁会自动撤销。

长时间持有：锁会在整个事务过程中持有，直到事务提交或回滚。

4.锁的常见类型：

Shared Lock（共享锁）：

允许多个事务并发读取数据，但不允许任何事务修改数据。

适用于读取操作。

Exclusive Lock（排他锁）：

只允许一个事务读取和修改数据，其他事务都不能读取或修改。

适用于修改操作。

Intent Lock（意图锁）：

用于表明某个事务打算对某一行/页加锁。

比如一个事务可能会给某行加排他锁，其他事务可以给这行加共享锁。

 **Latches（闩锁）**
1.功能：

闩锁是低层次的同步机制，主要用于保护数据库管理系统内部的临时结构和元数据结构，确保 多个线程同时修改同一数据结构时不会冲突。

2.作用：

物理级别的保护：用于短期操作，保护内存中的数据结构（例如哈希表、B+ 树的节点、内存缓存）。

闩锁的目的是 确保操作的原子性，即避免在操作过程中发生竞争条件。

举个例子：

你和我都在读取和修改一个内存中的哈希表节点。

为了保证你和我同时修改时不发生冲突，使用闩锁来确保同一时间只能有一个线程修改该节点。

3.特点：

临时性：闩锁的持有时间非常短，一般只在短时间内保护一块内存区域。

不能回滚：如果持有锁的线程失败，其他线程无法恢复锁的状态。

不影响事务：闩锁只是用来保证数据库内部的操作原子性，不会阻塞事务的进程。

4.闩锁的常见类型：

Exclusive Latch（排他闩锁）：

允许只有一个线程访问该数据结构。

适用于需要对数据结构进行修改的操作。

Shared Latch（共享闩锁）：

允许多个线程共享访问该数据结构，但不能进行修改。

适用于仅读取数据结构的操作。

 **一句话区分**

>Locks 保证“对不对”，Latches 保证“不乱”

# 六、为什么不用操作系统的 Page Cache？
**OS Page Cache / mmap 的问题**
❌ 1. 事务安全

OS 可能随时刷脏页

不管事务提交没

❌ 2. I/O Stall

DBMS 不知道 page 在不在内存

可能突然 page fault

查询直接卡死

❌ 3. 错误处理

访问坏页 → SIGBUS

DBMS 被迫处理异常

❌ 4. 性能问题

OS 内部锁竞争

TLB shootdown

“那能不能调 OS 行为？”

可以：

madvise

mlock

msync

👉 但：

折腾 OS，不如自己管理

**DBMS 自己管理的优势**

控制刷盘顺序

知道查询语义

专用替换策略

更好调度线程

# 七、Buffer Replacement Policy（淘汰策略）

当 Buffer Pool 满了：
👉 要踢谁出去？

 **LRU（最近最少使用）**

记录最后一次访问时间

淘汰最久没用的

❌ 问题：

时间戳维护成本高
**CLOCK（工业界常用）**
思想

LRU 的近似

每页一个 reference bit

工作方式

页面排成一个环

有个“指针”

扫描：

bit = 1 → 置 0，跳过

bit = 0 → 淘汰

**LRU / CLOCK 的问题**
顺序扫大表

一堆 page 快速进来

把真正“热数据”全挤掉


 **LFU（最少使用）**

记录访问次数

❌ 问题：

老数据永远不走

忽略时间

# 八、改进方案（重点）
**LRU-K**

记录最近 K 次访问

预测下次访问时间

❌ 成本高
❌ 需要 ghost cache

 **MySQL 的 LRU-2 近似**

young list

old list

访问策略：

在 old 再访问 → 进 young

淘汰只从 old 尾部

 **Localization per Query**

每个查询只污染自己的区域

不影响别人

 **Priority Hints**

查询告诉 Buffer Pool：

这个 page 重不重要

 **ARC（Adaptive Replacement Cache）**
核心思想

👉 动态平衡“最近性 + 频率”

四个列表

T1：最近访问一次

T2：访问 ≥2 次

Ghost T1 / T2：记住被踢的

参数 p：

控制偏向 recency 还是 frequency

# 九、Dirty Pages（脏页处理）
两种 eviction 路径
**Fast Path**

page 没 dirty

直接丢

**Slow Path**

page dirty

必须先写盘

**优化：Background Writing**

后台线程

提前把 dirty page 刷盘

eviction 时更快

# 十、Disk I/O & OS Cache
**OS 的行为**

合并 I/O

重排顺序

最大化吞吐

❌ 但不知道：

哪个请求更急

哪个是事务关键路径

**DBMS 自己维护 I/O 队列**

考虑：

顺序 vs 随机

前台 vs 后台

表 / 索引 / 日志

SLA

**Direct I/O**

使用 O_DIRECT

绕过 OS page cache

优点：

避免双缓存

避免两套 eviction 策略

**fsync 坑点**

默认可能 silent error

出错却标记 clean

# 十一、整讲一句话总结

>数据库之所以复杂，是因为它不信任操作系统，
而选择自己掌控：内存、磁盘、I/O、淘汰、并发。
