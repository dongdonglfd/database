

# 一、为什么 DBMS 需要索引（Indexes）

## 1. 索引解决什么问题？

**没有索引：**

* 查询只能做 **顺序扫描（Sequential Scan）**
* 时间复杂度：`O(N)`（表很大时极慢）
* 对磁盘 DBMS 来说 → 大量随机 I/O 或全表扫描

**有索引：**

* 用额外的数据结构，**快速定位 tuple 的物理位置**
* 只访问少量页面 → 极大减少 I/O

 **索引的本质定义（重点）**

> 索引是 **表中部分属性的副本**，以**某种结构组织/排序**，用于快速定位 tuple 的位置。

---

## 2. 索引的代价（Trade-off）

索引不是越多越好：

### 好处

* 查询更快（尤其是 WHERE、ORDER BY、JOIN）
* 避免全表扫描

### 代价

* 占用额外存储空间
* INSERT / DELETE / UPDATE 需要 **维护索引**
* 并发控制复杂（索引页也要加锁/闩）

 **核心思想**

> DBMS 的查询优化器负责决定：
> **“用不用索引、用哪个索引”**

---

# 二、为什么不用 Hash Index？→ 引出 B+Tree

Hash Index 的局限：

* ❌ 不支持 **范围查询**（`> < BETWEEN ORDER BY`）
* ❌ 不支持 **前缀匹配**
* ❌ 必须提供完整 key

👉 **B+Tree 的优势：**

* 有序
* 支持范围扫描
* 支持部分 key
* I/O 友好（磁盘顺序访问）

---

# 三、B+Tree 基础结构（非常重要）

## 1. B+Tree 是什么？

**B+Tree = 磁盘友好的自平衡多路搜索树**

性质：

1. **所有叶子在同一层（完全平衡）**
2. **非根内部节点至少半满**
3. **有 k 个 key 的内部节点 → k+1 个孩子**
4. **所有数据只存在于叶子节点**

与 B-Tree 的核心区别：

* **B-Tree**：数据可以在内部节点
* **B+Tree**：数据只在叶子节点（现代 DBMS 用）

---

## 2. 节点内部存什么？

### ① 内部节点（Inner Node）

* `<key, child pointer>`
* key 是 **路标（guide post）**
* key **不一定真的存在于叶子**

👉 内部节点的 key：

* **只用于导航**
* **不是最终答案**

---

### ② 叶子节点（Leaf Node）

两种常见方式：

#### 方式 1：Record ID（最常见）

```
key → RID(page_id, slot_id)
```

* 索引小
* tuple 在表里

#### 方式 2：直接存 tuple（索引组织表）

* clustered index
* MySQL InnoDB

---

## 3. Sibling Pointer（Blink-Tree）

* 叶子节点之间有 **右指针**
* 允许：

  * 顺序扫描（Range Scan）
  * 不回溯父节点
  * 并发插入/分裂更高效

 **为什么重要？**

```sql
WHERE key BETWEEN 10 AND 100
```

→ 找到第一个 → 顺着 sibling 一路扫

---

# 四、B+Tree 的插入（Insertion）

### 插入流程（非常经典）

1. 从根节点向下查找
2. 找到目标叶子 L
3. 插入 key（保持有序）

---

### 情况 1：叶子未满

✅ 直接插入，结束

---

### 情况 2：叶子满了 → **分裂**

* 拆成 L1 和 L2
* key 平均分
* **中间 key 复制到父节点**
* 父节点插入指向 L2 的指针

 **注意：叶子是 copy up**

---

### 内部节点分裂

* 同样拆分
* **中间 key 是 push up（不是 copy）**

 区别总结：

| 场景     | 中间 key  |
| ------ | ------- |
| 叶子分裂   | copy up |
| 内部节点分裂 | push up |

---

# 五、B+Tree 的删除（Deletion）

删除比插入复杂（DBMS 实现难点）

### 删除流程

1. 找到叶子 L
2.  删除 entry

---

### 情况 1：仍 ≥ 半满

✅ 什么都不用做

---

### 情况 2：低于半满

有两种选择：

#### ① 向兄弟 **借**

* 旋转 key
* 父节点 key 更新

#### ② 借不到 → **合并**

* 合并两个叶子
* 删除父节点中对应 entry
* 可能递归向上

 删除会 **向上传播**

---

# 六、复合索引（Composite Index）

```sql
CREATE INDEX idx ON table(a, b DESC, c NULLS FIRST);
```

### 排序顺序

* 先按 a
* 再按 b
* 再按 c

---

### 能用索引的条件（重点）

✅：

```sql
WHERE a = 1 AND b = 2 AND c = 3
WHERE a = 1
WHERE a = 1 AND b = 2
```

❌：

```sql
WHERE b = 2
WHERE a = 1 OR b = 2
```

**左前缀原则（Leftmost Prefix Rule）**

---

# 七、B+Tree vs Hash Index（核心对比）

| 特性   | B+Tree | Hash |
| ---- | ------ | ---- |
| 等值查询 | 快      | 快    |
| 范围查询 | ✅      | ❌    |
| 排序   | ✅      | ❌    |
| 前缀查询 | ✅      | ❌    |
| 磁盘友好 | ✅      | 一般   |

---

# 八、聚簇索引（Clustered Index）

## 1. 什么是聚簇索引？

> **表的数据物理顺序 = 索引顺序**

* 一张表 **最多一个**
* 通常是 **主键**

---

## 2. 优缺点

### 优点

* 范围查询极快
* 减少回表

### 缺点

* 插入代价高
* 主键变动 = 数据移动

---

# 九、Index Scan 的页面排序优化

**问题：**

* 非聚簇索引 → RID 指向随机页面
* 直接访问 → 大量随机 I/O

**优化：**

1. 先收集所有 RID
2. 按 page_id 排序
3. 每页只读一次

📌 这是 **查询执行器的重要优化**

---

# 十、B+Tree 的设计选择（Design Choices）

## 1. Node Size

| 场景    | 节点大小    |
| ----- | ------- |
| HDD   | 大（MB）   |
| SSD   | 中       |
| 内存 DB | 小（512B） |

📌 workload 决定设计

---

## 2. Merge Threshold

* 不一定立刻合并
* 避免频繁 split / merge（thrashing）
* Postgres 会延迟重构

---

## 3. 变长 key 的处理（非常重要）

### 最常用方案：**Key Indirection**

* key → dictionary
* 索引只存引用
* PostgreSQL 使用

---

## 4. 节点内搜索方式

| 方法            | 复杂度      | 特点  |
| ------------- | -------- | --- |
| Linear        | O(n)     | 插入快 |
| Binary        | O(log n) | 常见  |
| Interpolation | 最快       | 仅学术 |

---

# 十一、B+Tree 的高级优化

## 1. 前缀压缩（Prefix Compression）

* 相邻 key 共享前缀
* 极大节省空间

---

## 2. 去重（Deduplication）

* 相同 key → 只存一次
* 后接多个 value

---

## 3. 后缀截断（Suffix Truncation）

* 内部节点只保留 **最短路由前缀**

---

## 4. Pointer Swizzling

* page_id → 直接内存指针
* 减少 buffer pool 查找
* 需要 deswizzle

---

## 5. Bulk Insert

* 先排序
* 自底向上建树
* 减少 split

---
## 6. 写优化 B+Tree（Bω-Tree）

* 延迟写入
* 类似 LSM 思想
* 减少随机写
---


