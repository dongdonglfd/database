### 一、概述
SQL 是一种声明性语言，这意味着你告诉数据库系统你要什么结果，但你并没有指定具体的执行方式。所以，数据库系统需要将 SQL 查询转换为 **可执行的查询计划**。查询计划包含多个 **操作符**（例如连接操作），这些操作符之间可以以不同的方式执行，因此会有不同的性能。**查询优化器**的作用就是从多个查询执行计划中，选出最有效率的一个。

#### **查询优化器的历史：**

* 第一个查询优化器是 IBM System R，诞生于 1970 年代。当时很多人认为数据库系统无法比人工更好地生成查询计划，但现在的很多查询优化设计都源自于这个系统。

---

### 二、逻辑计划 vs 物理计划（Logical vs Physical Plans）

* **逻辑计划**：数据库优化器会将查询转换成 **逻辑查询计划**，这通常是一个包含关系代数运算符的树。它描述了查询的高层次操作，但并没有具体说明如何在硬件上执行这些操作。

* **物理计划**：这描述了如何具体执行每个操作符，包括如何访问数据（例如使用索引，排序或压缩）。物理计划是数据库的 **执行策略**，它依赖于数据的物理存储格式。

这两个计划之间的转换是数据库优化的关键。

---

### 三、关系代数等价（Relational Algebra Equivalence）

* 查询优化的一个重要概念是 **关系代数的等价性**。如果两个关系代数表达式生成相同的元组集合，它们就是等价的。优化器通过 **查询重写** 来实现这一点。

#### **例子**：**谓词下推（Predicate Pushdown）**

* 在查询计划中，有时可以将过滤条件（谓词）提早应用，减少不必要的工作。比如，如果你在连接操作之前就应用了过滤条件，那么就能避免将无关的元组带入连接操作中，从而节省时间。

**示例**：

* 比如，`SELECT * FROM A JOIN B ON A.id = B.id WHERE A.age > 30;`，我们可以提前把 `A.age > 30` 这个条件放到 `A` 的扫描操作中，而不是等到连接后再应用。

---

### 四、查询优化的两大策略（Types of Query Optimization）

1. **静态规则（Heuristics）**：使用一些已知的模式来转换查询。这些规则会通过 **查询模式匹配**，自动将查询转换成更高效的计划。例如，提前应用过滤条件，重排序谓词等。规则不需要查询数据本身，只需要理解数据库结构。

2. **基于成本的优化（Cost-based optimization）**：数据库会执行多个查询计划，并计算每个计划的 **执行成本**，选择成本最低的计划。成本通常是基于 **CPU、磁盘 I/O、内存和网络** 等度量来估算的。

---

### 五、逻辑查询优化（Logical Query Optimization）

* **逻辑优化** 的目标是通过模式匹配规则，把 **逻辑查询计划** 转换成一个等价但更加高效的逻辑查询计划。常见的优化包括：

#### 1. **谓词下推（Predicate Pushdown）**

* **目的**：尽可能早地应用过滤条件，减少后续处理的数据量。
* **例子**：把过滤条件 `A.age > 30` 提前放到 `A` 的扫描阶段，而不是等到连接后再应用。

#### 2. **投影下推（Projection Pushdown）**

* **目的**：尽早把不需要的列移除，减少中间结果的大小。
* **例子**：查询只需要 `student_name` 和 `student_id`，那么在做连接前就只选择这两个字段，而不是选择所有字段。

---

### 六、基于成本的查询优化（Cost-Based Query Optimization）

1. **代价估算**：数据库系统使用 **成本模型** 来评估不同执行计划的成本。比如：

   * **CPU**：执行算子的时间消耗。
   * **磁盘 I/O**：从磁盘读取数据的成本。
   * **内存**：查询过程中使用的内存大小。
   * **网络**：网络传输的成本。

2. **查询计划枚举**：由于查询中存在很多可能的执行顺序，优化器会生成多个候选查询计划并评估它们的成本，最终选择最优的计划。

#### **问题**：

* 对于 **多表连接**，可能有大量不同的连接顺序，因此优化器需要限制其搜索空间，才能在合理的时间内找到最佳计划。

---

### 七、查询计划的优化策略

1. **单表查询优化（Single-Relation Query Plans）**：

   * 对于单表查询，选择 **扫描方法**（如：顺序扫描、索引扫描）是关键。对于 OLTP 查询，通常会使用简单的启发式规则来选择合适的索引。

2. **多表查询优化（Multi-Relation Query Plans）**：

   * 对于多表连接，随着表的增多，查询计划的选择空间呈指数级增长。因此，优化器通常会限制搜索空间，以便能够在合理时间内找到最优的执行计划。

   #### **优化方式**：

   * **生成式优化 / 自下而上（Generative / Bottom-up）**：从最底层开始构建查询计划，例如 IBM System R 和 MySQL。
   * **转化式优化 / 自上而下（Transformation / Top-down）**：从目标计划开始工作，逐步向下查找最优的执行计划。

---

### 八、子查询优化（Nested Sub-Queries）

* 子查询常常出现在 `WHERE` 子句中。数据库优化器会把子查询 **重写成连接操作**，以便更高效地执行。
* **优化方法**：

  * **去相关化（Decorrelation）**：将相关子查询转化为不相关的形式。
  * **扁平化（Flattening）**：将多层嵌套子查询简化为平坦的查询。

#### **示例**：子查询优化

* 假设原始查询是：

  ```sql
  SELECT * FROM orders WHERE customer_id IN (SELECT customer_id FROM customers WHERE age > 30);
  ```

  优化器可以将其改写为：

  ```sql
  SELECT * FROM orders JOIN customers ON orders.customer_id = customers.customer_id WHERE customers.age > 30;
  ```

  这种方式使得数据库系统可以通过连接操作而不是嵌套查询来处理。

---

### 九、表达式重写（Expression Rewriting）

* 数据库优化器会对查询中的 **WHERE/ON 子句的表达式** 进行 **重写**，目的是消除不必要的计算。

#### **常见的表达式重写**：

1. **常量折叠（Constant Folding）**：将计算表达式中的常量部分提前计算好，避免每次执行时重新计算。
2. **合并冗余谓词（Merging Predicates）**：对于多个相同条件的谓词，进行合并简化。比如：

   ```sql
   WHERE A BETWEEN 1 AND 150 AND A < 100
   ```

   优化后：

   ```sql
   WHERE A BETWEEN 1 AND 100
   ```

---

### 总结：

1. **查询优化器** 的任务是根据 SQL 语句生成最优的执行计划。它首先将 SQL 转换成逻辑查询计划，然后通过规则（如谓词下推）和成本估算选择最佳的物理查询计划。
2. 查询优化的 **两种主要策略**：

   * **静态规则**：使用预定义的规则来改写查询计划。
   * **基于成本的优化**：枚举多个查询计划并计算其成本，选择成本最低的计划。
3. **优化方法**：包括谓词下推、投影下推、子查询重写、表达式重写等，所有这些优化都旨在 **减少计算量和 I/O 操作**。
好的，让我们继续用 **通俗易懂** 的方式详细讲解 **Lecture 16: Query Planning & Optimization II** 这节课的内容，专注于 **查询规划和优化** 的更多细节。我们将逐步讲解每个概念和技术。

---

### 十、**多关系查询计划**（Multi-Relation Query Plans）

对于 **多表查询**，尤其是有多个连接操作时，查询计划的选择空间会 **指数增长**。也就是说，当你连接的表越多，可能的执行计划就越多，因此，优化器需要找到一个高效的方式来选择最优的查询计划。

#### **优化查询计划的两种方式**：

1. **生成式优化 / 自下而上（Generative / Bottom-up）**：

   * 这种方式从最基础的操作开始，一步步构建查询计划，直到得到最终的执行结果。最常见的做法是使用 **动态规划** 来确定最好的连接顺序。开源数据库系统（如 MySQL、Postgres）大多使用这种方式。
   * **流程**：

     * 将查询拆分成若干块，针对每一块生成逻辑操作符。
     * 对每个逻辑操作符，生成一组物理操作符来实现它。
     * 最后，通过构建一个**左深树**来最小化执行计划的工作量。

2. **转化式优化 / 自上而下（Transformation / Top-down）**：

   * 这种方式从目标查询计划开始，逐步向下转化来找到最优的执行计划。这个方法一般会用 **递归转换规则** 来不断应用逻辑和物理规则，优化查询计划。**Volcano** 是采用这种方法的优化器。
   * **流程**：

     * 通过递归地查找等价的表达式和子计划的最优实现，持续优化查询计划。

---

### 十一、**数据统计**（Data Statistics）

优化器需要知道关于数据的统计信息，以便能够估算查询计划的成本。由于真实数据往往是 **偏斜的**，直接假设所有数据分布均匀是非常困难的。因此，数据库会利用 **数据统计** 来近似估算数据的特征。

#### **1. 直方图（Histograms）**

* **直方图**是将数据的分布信息通过“桶”（buckets）来汇总，这样可以大大减少存储空间。具体地，数据会根据值的范围划分到不同的桶中。

* **等宽直方图**：将数据划分为固定宽度的区间。例如，把年龄从 0 到 100 分为 10 个区间。

  * **优点**：简单，存储高效。
  * **缺点**：不能很好地处理数据的偏斜情况。

* **等深直方图**：将数据划分为每个桶包含大致相同数量的数据。这种方式适合处理数据的 **偏斜**（例如某些值出现得特别多）。

  * **优点**：能够保证每个桶的数据量大致相同。
  * **缺点**：桶的宽度会不均匀，可能导致一些桶的范围很大。

* **倾斜的直方图（End-biased Histogram）**：存储最频繁出现的键的具体计数，并将其余的值放在一个桶里，计算它们的 **平均频率**。这种方式适合当某些键频繁出现时。

#### **2. 采样（Sampling）**

* **采样** 是一种通过从表中选取一部分数据来进行 **估算** 的方法。数据库可以使用样本数据来近似计算查询的选择性（selectivity）。如果表数据非常大，采样能够有效减少估算的时间和计算量。

* **两种采样方法**：

  * **只读副本**：维护一个只读的样本副本，定期更新。
  * **实时采样**：直接从实际的表中抽取样本，随着数据的变化（例如，数据变化超过 10%）来更新样本。

---

### 十二、**成本估算**（Cost Estimations）

数据库系统使用 **成本模型** 来评估查询计划的执行成本。查询的成本会根据多个因素来估算：

* **CPU**：计算开销，估算起来比较难。
* **磁盘 I/O**：磁盘读取块的数量，是影响查询性能的关键因素。
* **内存**：查询过程中使用的内存大小。
* **网络**：查询执行过程中发送的网络消息数量。

**问题**：

* **查询计划的枚举**：对于一个查询，可能有很多执行计划的排列组合，尤其是 **连接操作** 的顺序和方式，优化器需要在有限的时间内限制枚举的搜索空间，以便高效地选择最优计划。

#### **选择性（Selectivity）估算**

* 选择性是指某个谓词（例如 `WHERE age > 30`）筛选出的元组的比例。数据库优化器使用 **选择性** 来估算查询的执行成本。

* **简单谓词的选择性**：对于 **等值谓词**，选择性很容易估算（例如 `age = 30`）。

* **复杂谓词的选择性**：对于范围查询、多个条件的连接查询等复杂谓词，选择性比较难估算，因为需要对多个条件的选择性进行结合计算。常见的 **选择性假设** 包括：

  * **均匀数据**：假设数据在各个属性上的分布是均匀的。
  * **独立谓词**：假设不同条件之间是独立的。
  * **包含原则**：假设连接键的域是重叠的。

---
### 十三、**连接大小估算**（Join Size Estimation）

对于两个关系 R 和 S 的连接操作，估算连接结果的大小非常重要。目标是估算 **每个 R 中的元组** 与 **S 中的元组** 可能匹配的数量。估算连接的大小时，我们会做以下假设：

* **均匀数据**：数据分布是均匀的。
* **独立谓词**：谓词之间是独立的。
* **包含原则**：连接的键的值在外表和内表中是共享的。

#### **估算公式**：

对于一个基于某个属性 A 的连接，假设属性 A 在关系 R 中有 **V(A, R)** 种不同的值，在关系 S 中有 **V(A, S)** 种不同的值，那么连接的大小可以估算为：
[ \text{Join Size} \approx \frac{NR \times NS}{\max(V(A,R), V(A,S))} ]
其中：

* **NR**：关系 R 中的元组数。
* **NS**：关系 S 中的元组数。

---

### 十四、**总结**

在数据库优化中，查询优化是一个复杂的过程，它的核心任务是从多种可能的执行计划中，选出性能最好的一个。优化器通过不同的 **查询重写策略**（如谓词下推、投影下推）和 **基于成本的优化方法**（如选择性估算、连接大小估算）来实现高效的查询执行。

**关键概念**：
1. **多表查询的优化**：通过生成式（自下而上）和转化式（自上而下）优化方法来优化查询计划。
2. **数据统计**：使用直方图、采样等技术来对数据的特征进行估算，帮助优化器做出决策。
3. **成本估算**：利用选择性、I/O、CPU 和内存等指标来评估不同查询计划的成本。
4. **连接优化**：通过估算连接大小和选择合适的连接算法来优化查询的执行。

