# 一、先搞清楚：数据库为什么会“崩”还要能恢复？
## 1️⃣ 崩溃（Crash）到底指什么？

崩溃不是逻辑错误，而是：

* 断电 ⚡
* 操作系统崩溃
* 进程被 kill
* 机器重启

**关键点：**

* **内存（RAM）里的东西全没了**
* **磁盘（SSD / HDD）里的东西还在**

---

## 2️⃣ 为什么这会变成一个大问题？

因为数据库为了**快**，大量用内存：

* 更新先写内存
* 过一会儿再慢慢写磁盘

👉 如果这时崩了：

* 用户明明看到「提交成功」
* 但数据只在内存
* 重启后：**数据消失**

这就违反了数据库最基本的承诺：

> **Durability（持久性）：我告诉你提交成功，就一定不能丢**

---

## 3️⃣ Recovery Algorithm（恢复算法）要干啥？

一句话版：

> **不管什么时候崩，我都能把数据库恢复到“合理状态”**

合理 = 保证三件事：

1. **Atomicity（原子性）**

   * 事务要么全做完
   * 要么一点没做

2. **Consistency（一致性）**

   * 数据不乱

3. **Durability（持久性）**

   * 已提交的数据一定还在

---
## 4️⃣ 所有恢复算法都有两部分

### （1）正常运行时偷偷做的事

比如：

* 记日志
* 复制旧数据
* 标记事务状态

### （2）崩溃后做的事

比如：

* 撤销没完成的事务（UNDO）
* 重放已提交的事务（REDO）

---

## 5️⃣ 两个“终极武器”：UNDO & REDO

### UNDO（撤销）

> 把「没完成 / 已回滚」事务的影响抹掉

生活比喻：

* 写作业写一半被老师说“作废”
* 把橡皮擦回来

---

### REDO（重做）

> 把「已经提交但没写进磁盘」的修改重新做一遍

生活比喻：

* 你已经付款成功
* 但系统还没记账
* 重启后要**重新记一遍**

---

# 二、Buffer Pool 策略（这是整个 Logging 的地基）

数据库数据在两个地方：

* **内存（Buffer Pool）**：快
* **磁盘（Disk）**：慢但安全

问题是：
👉 **什么时候可以把内存里的脏数据写回磁盘？**

---

## 1️⃣ STEAL vs NO-STEAL（能不能“偷写”？）

### STEAL（允许偷）

> **允许把“未提交事务”的修改写到磁盘**

比喻：

* 作文还没交
* 老师先帮你存进档案柜

好处：

* 内存压力小
* 大事务也能跑

坏处：

* 崩溃后要 **UNDO**

---

### NO-STEAL（不允许偷）

> **没提交，绝对不能写磁盘**

比喻：

* 作文没交
* 只能放你自己书包里

📌 好处：

* 不需要 UNDO
  📌 坏处：
* 内存很快爆炸

---

## 2️⃣ FORCE vs NO-FORCE（提交时强制写盘吗？）

### FORCE（强制）

> 提交时，必须把所有修改写进磁盘

好处：

* 不需要 REDO
 坏处：
* 提交非常慢（大量随机 IO）

---

### NO-FORCE（不强制）

> 提交只要“保证能恢复”，不用立刻写盘
好处：

* 提交很快
 坏处：
* 崩溃后要 REDO

---

## 3️⃣ 四种组合，哪种能用？

| 组合                  | 能用吗 | 评价        |
| ------------------- | --- | --------- |
| NO-STEAL + FORCE    | ✅   | 简单但慢      |
| STEAL + NO-FORCE    | ✅   | **工业界首选** |
| STEAL + FORCE       | ❌   | 没意义       |
| NO-STEAL + NO-FORCE | ❌   | 没优势       |

---

# 三、最傻但最直观：NO-STEAL + FORCE

## 1️⃣ 它怎么工作？

* 所有修改只在内存
* 提交时：

  * 把**本事务的所有修改**写进磁盘
* 未提交的事务：

  * **绝不会污染磁盘**

---

## 2️⃣ 为什么不用日志？

因为：

* 不会把脏数据写盘 → 不需要 UNDO
* 提交时全写盘 → 不需要 REDO

---

## 3️⃣ 致命问题（很重要）

### ❌ 事务写的数据必须全部放得进内存

如果一个事务：

* 要更新 100GB 数据
* 但内存只有 16GB

👉 **事务根本跑不起来**

---

# 四、Shadow Paging（聪明一点的 NO-STEAL + FORCE）

## 1️⃣ 核心思想（一句话）

> **不覆盖原数据，而是“写新副本，提交时一键切换”**

---

## 2️⃣ 两个世界

### Master（正式世界）

* 只包含**已提交数据**
* 所有读事务默认看这里

### Shadow（影子世界）

* 当前事务的修改
* 不影响别人

---

## 3️⃣ 怎么实现的？

数据库页面组织成一棵树（像 B+ 树）：

```
Root
 ├── Page A
 ├── Page B
 └── Page C
```

* Root 指向 **Master Page Table**
* 更新时：

  * 复制路径上的页面
  * 修改副本
  * Shadow Page Table 指向新页面

---

## 4️⃣ 提交 = 原子切换指针

提交时只做一件事：

> **把 Root 指针从 Master 指向 Shadow**

这一步是：

* 一个磁盘写
* 原子操作

---

## 5️⃣ 崩溃恢复超级简单

* 崩前没提交？

  * Root 还指着 Master
  * Shadow 直接丢
* **不需要 REDO**
* **不需要 UNDO**

---

## 6️⃣ 但为什么现在不用了？

### ❌ 缺点很多

1. **复制页表很贵**
2. **提交要写很多随机页**
3. **磁盘碎片严重**
4. **多事务并发几乎不可用**

👉 所以现在基本不用

---

# 五、Journal File（SQLite 早期方案）

## 1️⃣ 思想

> **改之前，先把“原始页”存到小本本里**

---

## 2️⃣ 工作流程

1. 修改页面 P
2. 把 **P 的原始内容** 复制到 journal 文件
3. 再修改磁盘里的 P

---

## 3️⃣ 崩溃恢复

* 如果发现 journal 文件存在：

  * 把里面的旧页面写回原位置
  * 恢复到事务前状态

👉 简单粗暴：**一律回滚**

---

## 4️⃣ 局限

* 一次只能一个写事务
* 性能一般

👉 SQLite 2010 后改用 WAL

---

# 六、Write-Ahead Logging（现代数据库的王者）

## 1️⃣ WAL 的一句话定义

> **“先记账，再干活”**

---

## 2️⃣ 核心规则（这是金科玉律）

> **在把数据页写进磁盘之前，
> 对应的日志必须先写进磁盘**

---

## 3️⃣ WAL 是 STEAL + NO-FORCE

* 允许写脏页 → 解决内存问题
* 提交不写数据页 → 提交快
* 代价：

  * 需要 UNDO
  * 需要 REDO

---

## 4️⃣ WAL 的实际流程（一步不跳）

### 事务开始

```
<BEGIN, txn_id>
```

---

### 修改一条数据

写日志（在内存里的 log buffer）：

```
<txn_id, page_id, before_value, after_value>
```

---

### 提交事务

1. 写：

```
<COMMIT, txn_id>
```

2. **把该事务所有日志 flush 到磁盘**
3. 告诉用户：提交成功

⚠️ 注意：

* **此时数据页可能还没写磁盘**

---

## 5️⃣ 为什么这样安全？

因为：

* 崩溃后：

  * 有日志 → 可以 REDO
  * 有 before value → 可以 UNDO

---

## 6️⃣ Group Commit（性能神器）

多个事务：

* 一起刷日志
* 分摊一次磁盘 IO

👉 吞吐量暴涨

---

## 7️⃣ MVCC 和 WAL 的完美配合（重点）

> 如果数据库已经保存旧版本（MVCC）
> 那 **UNDO 不一定需要 before value**

因为：

* 老版本已经在版本链里

---

# 七、日志内容的三种方案

## 1️⃣ Physical Logging（物理）

* 记录字节级修改
* 快
* 但强依赖存储布局

---

## 2️⃣ Logical Logging（逻辑）

* 记录 SQL 操作
* 日志小
* 恢复慢、并发难

---

## 3️⃣ Physiological Logging（现实选择）

* 记录：

  * 页号
  * slot 号
  * 修改内容
* **不关心页内部布局**

👉 **绝大多数 DBMS 用这个**

---

# 八、Checkpoint（否则日志会爆炸）

## 1️⃣ 为什么要 Checkpoint？

* WAL 会无限增长
* 崩溃后从头 replay → 要几小时甚至几天

---

## 2️⃣ Checkpoint 干嘛？

1. 把所有脏页写盘
2. 写一条：

```
<CHECKPOINT>
```

3. 之前的日志可以删

---

## 3️⃣ Blocking Checkpoint（最简单）

* 停止接新事务
* 等所有事务完成
* 全刷盘
* 写 checkpoint

简单但影响性能

---

# 九、终极总结

> **数据库恢复的核心思想是：**
>
> * 内存快但不安全
> * 磁盘慢但可靠
> * 用日志连接两者
>
> **WAL = 用顺序写日志换随机写数据**
>
> **STEAL + NO-FORCE = 快运行，慢恢复**
>
> **Checkpoint = 用空间换恢复时间**

