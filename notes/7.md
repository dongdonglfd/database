
> **“不同类型的查询，需要完全不同的索引结构。”**

---

## 一、Index vs. Filter（索引 vs 过滤器）

### 什么是 Index（索引）？

👉 **索引回答的是：数据在哪里？**

* 给定一个 key
* 告诉 DBMS：
  👉 **这个 key 对应的元组在磁盘的哪一页、哪一个 slot**

典型例子：

* B+ 树索引
* 哈希索引
* Skip List

它们的目标是：
**“快速定位数据的物理位置”**

---
### 什么是 Filter（过滤器）？
👉 **过滤器回答的是：某个东西「可能在不在」集合里？**

* 它不告诉你数据在哪里
* 只告诉你：

  * ❌ **一定不在**
  * ✅ **可能在（但不保证）**

👉 作用：
**避免做没必要的“昂贵查找”**

---

### Index + Filter = 经典组合

举个非常重要的例子（老师很喜欢考）：

#### 哈希表 + Filter

* 哈希桶里是一个链表（chained hash）
* 每个桶前面放一个 Bloom Filter

查 key = X：

1. 先查 Bloom Filter
2. 如果 filter 说 **不在**

   * 👉 直接跳过这个桶
3. 如果 filter 说 **可能在**

   * 👉 再去遍历链表

✅ **省掉大量无用的链表遍历**

---



## 二、 Bloom Filter（布隆过滤器）

### Bloom Filter 是什么？

👉 一种 **概率型过滤器（probabilistic filter）**

特点非常重要：

* ✅ **不会漏报（no false negative）**
* ❌ **可能误报（false positive）**

意思是：

| 查询结果 | 是否可能出错   |
| ---- | -------- |
| “不在” | ❌ 一定正确   |
| “在”  | ⚠️ 可能是假的 |

---

### Bloom Filter 的核心结构

Bloom Filter 由两部分决定：

1. **一个位图（bitmap）**
2. **k 个哈希函数**

---

### 插入 Insert(x)

对元素 `x`：

1. 用 k 个 hash 函数
2. 得到 k 个 hash 值
3. 对 bitmap size 取模
4. 把对应的 bit 置为 1

👉 **不会存 x 本身，只改 bit**

---

### 查询 Lookup(x)

1. 同样用 k 个 hash
2. 检查对应的 k 个 bit
3. 只要有一个是 0：

   * ❌ 一定不在
4. 如果全是 1：

   * ⚠️ 可能在（要去真正结构里确认）

---

### Bloom Filter 的限制

❌ **不能删除元素**

原因：

* bit 是共享的
* 清 0 可能误伤其他元素

---

### Bloom Filter 的变种

#### 1️⃣ Counting Bloom Filter

* bit → 计数器
* 插入 +1，删除 -1
* ✅ 支持删除

---

#### 2️⃣ Cuckoo Filter

* 类似 Cuckoo Hash
* 存的是 **指纹（fingerprint）**
* 支持插入 / 删除
* 空间效率更好

---

#### 3️⃣ Succinct Range Filter

* 紧凑的不可变 Trie
* 支持：

  * 精确匹配（近似）
  * 范围过滤
* 常用于 **LSM Tree**

---

Bloom Filter 经典用途：

* LSM Tree 的 SSTable 级别过滤
* 哈希索引的桶过滤
* 索引前置过滤

---

## 三、Skip List（跳表）

### Skip List 是什么？

👉 **多层有序链表**

本质：

* 最底层：完整的有序链表
* 上面每一层：抽样（大约 1/2）

👉 看起来像：

* **“链表版的 B+ 树”**

---

### 查找 Find

1. 从最上层开始
2. 向右走，直到要超过目标
3. 向下走一层
4. 重复
5. 最后在底层命中

👉 平均复杂度：**O(log n)**

---

### 插入 Insert

关键点：**抛硬币**

* 插入底层
* 每抛一次正面：

  * 再往上一层插一个节点
* 直到失败

📌 **为什么从下往上插？**

因为：

* 防止其他线程看到“悬空节点”
* 保证结构一致性

---

### 删除 Delete

不是立刻删：

1. 先标记 `deleted = true`
2. 查询线程遇到直接跳过
3. 后台线程：

   * 从上到下真正删除

👉 **典型的延迟删除 + 并发友好**

---

### Skip List 的优缺点

✅ 优点：

* 不需要像 B+ 树那样 rebalance
* 实现简单
* 非常适合 **内存结构（MemTable）**

❌ 缺点：

* 不适合磁盘（cache / locality 差）
* 反向扫描困难

---

## 四、Trie（字典树 / 前缀树）

### Trie 为什么存在？

B+ 树的问题：

> 在中间节点，**你不知道下面有没有这个 key**
>
> 👉 必须一路走到叶子（每层一次 I/O）

---

### Trie 的核心思想

👉 **按 key 的“字符 / bit”一层一层走**

* 每一层是 key 的一部分
* 树结构由 key 本身决定
* 和插入顺序无关
* 不需要 rebalance

---

### 查找复杂度

* O(k)
* k = key 的长度

📌 与数据量无关！

---

### Trie 的 fan-out（分支数）

* 1 bit → 2 路
* 1 byte → 256 路
* n-way Trie → n 个分支

---

### Trie 的压缩优化

#### 1️⃣ 水平压缩（Horizontal）

* 已知 fan-out
* 用数组代替 map
* 更省空间 / 更快

---

#### 2️⃣ 垂直压缩（Vertical / Radix Tree）

* 只有一个孩子的路径合并
* 减少高度

⚠️ 问题：

* key 不再完全嵌在树里
* 👉 可能 **false positive**
* 必须回表验证

---

## 五、Inverted Index（倒排索引）

### 为什么需要倒排索引？

B+ 树 / 哈希索引：

* 只能做：

  * 点查
  * 范围查

❌ **不能做关键词搜索**

---

### 倒排索引是什么？

👉 **从词 → 包含这个词的文档列表**

```
"Pavlo" → [doc1, doc7, doc23, ...]
```

* 词 → posting list（文档 ID 列表）

---

### Lucene 的实现（非常重要）

使用 **Finite State Transducer（FST）**

* 类似 Trie
* 但：

  * 边上存的是权重
  * 走完整个词
  * 权重累加 = 词在字典中的偏移

✅ 优点：

* 不存指针
* 极度压缩
* 不可变（immutable）

---

### 支持增量更新？

* 新词 → 新建一个小 FST
* 后台合并多个 FST

👉 **和 LSM Tree 思想一模一样**


---

### 倒排索引增强功能

* 排名（TF-IDF）
* n-gram（模糊搜索 / 自动补全）

---

## 6️⃣ Vector Index（向量索引）

### 为什么传统索引不够？

关键词搜索：

* 必须“字面相同”

❌ 无法理解语义

---

### 向量索引解决什么？

* 文本 → embedding（向量）
* 语义相似 → 向量距离近

👉 查询变成：

> **最近邻搜索（Nearest Neighbor Search）**


---

## 七、索引优化（Optimizations）

### 1️⃣ Partial Index（部分索引）

```sql
CREATE INDEX idx_recent
ON orders(date)
WHERE date >= '2025-01-01';
```

👉 只给**常查子集**建索引

---

### 2️⃣ Index Include Columns（覆盖索引）

* 额外列只放在 **叶子节点**
* 不参与搜索 key

👉 如果查询只用到索引里的列：

* **不用回表**
* Index-only scan

---

## 全局总结（非常重要）

| 结构             | 解决什么问题   |
| -------------- | -------- |
| B+ 树           | 点查 + 范围  |
| Hash           | 精确等值     |
| Bloom Filter   | 快速排除     |
| Skip List      | 内存有序     |
| Trie           | 前缀 / 字符级 |
| Inverted Index | 关键词搜索    |
| Vector Index   | 语义搜索     |

---

