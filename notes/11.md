# 一句话先给结论（先给你个大图）

**一句话版：**

> 数据库执行 SQL，不是“一行一行解释 SQL”，
> 而是：
> **先把 SQL 变成一棵“算子树”，然后按某种“执行模型”，一边从底下拿数据，一边往上加工，最后吐结果。**

下面我分 **5 大块**给你讲，每一块都用**生活比喻 + 细节拆解**。

---

## 一、什么是 Query Plan（查询计划）？

### 1️⃣ SQL ≠ 执行方式

你写的 SQL：

```sql
SELECT name
FROM student
WHERE age > 20;
```

数据库**不会**直接“读 SQL 执行”。

它会先翻译成一个 **Query Plan（查询计划）**，你可以理解成：

> 👉 **一张“加工流水线图”**

---

### 2️⃣ Query Plan 是什么样？

它通常是：

* **一棵树（或 DAG）**
* **叶子节点**：从表里拿数据
* **中间节点**：过滤、连接、聚合
* **根节点**：输出结果

举个简单的树 🌳：

```
        Project(name)
             |
        Filter(age > 20)
             |
       Seq Scan(student)
```

👉 数据流方向：
**从下往上流**（像自来水）

---

### 3️⃣ Pipeline（流水线）是什么？

如果算子可以 **“边拿数据边往上传”**，我们叫它：

> **Pipeline（流水线）**

就像工厂：

* 下游做一个
* 立刻交给上游
* 不用等全做完

---

### 4️⃣ Pipeline Breaker（流水线破坏者）

有些算子 **必须等所有数据到齐才能干活**：

典型例子：

* `ORDER BY`
* `GROUP BY`
* `JOIN` 的 build 阶段
* 子查询

👉 就像：

> 排名 → **你得先知道所有人的分数**

这种算子叫：
**Pipeline Breaker**

---

## 二、Processing Model（执行模型）到底在管什么？

### 1️⃣ 执行模型 = 干活方式

**执行模型决定三件事：**

1. 谁主动（上面拉？下面推？）
2. 一次处理多少数据（一条？一批？全部？）
3. 数据怎么在算子之间传

---

## 三、Iterator Model（迭代器模型）——最经典的

### 1️⃣ 用一句人话说

> **“你要一条，我才给你一条”**

---

### 2️⃣ 每个算子都实现一个 `Next()`

规则非常简单：

```cpp
Tuple* Next();
```

* 每调用一次 `Next()`
* 就返回 **一条 tuple**
* 没了就返回 `NULL`

---

### 3️⃣ 谁调用谁？

👉 **父节点调用子节点**

比如：

```
Project
  ↓ Next()
Filter
  ↓ Next()
Seq Scan
```

执行过程像这样：

1. Project：我要一条
2. Filter：我去问 Scan
3. Scan：给你一条
4. Filter：判断 age > 20
5. 合格 → 传给 Project

---

### 4️⃣ 像不像生成器？像！

你可以把它想成：

```cpp
while (auto t = child->Next()) {
    if (predicate(t)) {
        return t;
    }
}
```

---

### 5️⃣ Iterator Model 的优点

✅ **非常好理解**
✅ **算子高度解耦**
✅ **天然支持 pipeline**
✅ `LIMIT` 很好做（要够了就不拉了）

---

### 6️⃣ 缺点

❌ `Next()` 是函数调用（虚函数）
❌ 调用次数非常多
❌ CPU 分支预测不友好

👉 对 OLAP（大量数据）不够快

---

## 四、Materialization Model（物化模型）

### 1️⃣ 用人话说

> **“我一次性全算完，再一次性给你”**

---

### 2️⃣ 不再是 `Next()`，而是 `Output()`

```cpp
vector<Tuple> Output();
```

执行逻辑：

1. 子算子：全吐出来
2. 父算子：在内存里一次性处理

---

### 3️⃣ 举个例子

```
Seq Scan → Filter → Project
```

流程是：

* Scan：扫完整个表
* Filter：过滤出一个结果集
* Project：一次性投影

---

### 4️⃣ 适合什么场景？

✅ **OLTP**

* 查询小
* 行数少
* 函数调用少 → 快

---

### 5️⃣ 最大问题

❌ 中间结果可能 **非常大**
❌ 容易 **爆内存 / 写磁盘**

---

## 五、Vectorized Model（向量化 / 批处理模型）

### 1️⃣ 用一句话说

> **“一次处理一筐数据，而不是一个”**

---

### 2️⃣ 和 Iterator 的区别

Iterator：

```text
一次 1 条
```

Vectorized：

```text
一次 N 条（比如 1024）
```

---

### 3️⃣ 为什么快？

因为现代 CPU 喜欢：

* 连续内存
* for 循环
* SIMD
* cache 命中

👉 **for 循环 > 函数调用**

---

### 4️⃣ 执行流程

```cpp
Batch NextBatch();
```

* 算子内部：for 循环
* 外部：批量传递

---

### 5️⃣ 适合谁？

✅ **OLAP**

* 全表扫描
* 聚合
* 分析型查询

---

## 六、Processing Direction（执行方向）

### 1️⃣ Top-Down（Pull）

最常见：

* 父节点 `pull`
* 子节点 `Next()`

优点：

* 好控制 `LIMIT`
* 实现简单

缺点：

* 函数调用多

---

### 2️⃣ Bottom-Up（Push）

* 子节点主动 `push`
* 父节点被动接收

优点：

* cache 利用好
* 指令更紧凑

缺点：

* 难控制中间结果
* 实现复杂

---

## 七、Access Methods（数据是怎么拿出来的）

### 1️⃣ Sequential Scan（顺序扫描）

👉 **一页一页读整张表**

你可以理解成：

> 拿着名单，从头念到尾

---

### 2️⃣ 为什么它慢？

* 读很多不需要的数据
* IO 多
* CPU 判断多

---

### 3️⃣ 但它也有很多优化

通俗解释版：

| 技术                   | 人话             |
| -------------------- | -------------- |
| 压缩                   | 一次读多条          |
| 预取                   | 提前把后面的页搬进来     |
| Buffer Bypass        | 不污染缓存          |
| 并行扫描                 | 多个人一起念         |
| Late Materialization | 不急着拼完整 tuple   |
| Zone Map             | 先看“目录”，不合格直接跳过 |

---

### 4️⃣ Zone Map（重点！）

每一页都有统计信息：

* min
* max

查询：

```sql
WHERE value > 600
```

如果某页 `max = 400`：

👉 **整页直接跳过**

---

## 八、Index Scan（索引扫描）

### 1️⃣ 用人话说

> **“先查目录，再找具体页”**

---

### 2️⃣ 什么时候用索引？

* 条件过滤性强
* 返回行数少

---

### 3️⃣ 多索引扫描（Multi-Index）

多个索引：

* 分别找 Record ID
* 再求交集

就像：

> 数学 + 英语成绩都及格的人

---

## 九、修改语句 & Halloween Problem（万圣节问题）

### 1️⃣ 问题是什么？

UPDATE 过程中：

* 更新导致 tuple 位置改变
* 扫描又扫到它一次
* 无限循环 😱

---

### 2️⃣ 解决方法

👉 **记录已经更新过的 RID**

---

## 十、表达式求值（WHERE 是怎么执行的）

### 1️⃣ WHERE 被表示成一棵树

```sql
age > 20 AND score > 90
```

变成：

```
        AND
       /   \
   age>20  score>90
```

---

### 2️⃣ 逐节点解释很慢

* 分支多
* 函数调用多

---

### 3️⃣ 优化手段

| 技术     | 人话      |
| ------ | ------- |
| 常量折叠   | 只算一次    |
| 公共子表达式 | 重复的只算一次 |
| JIT    | 直接生成机器码 |
| 向量化    | 一批一起算   |

---

## 总图

```
SQL
 ↓
Query Plan（算子树）
 ↓
执行模型（Iterator / Materialized / Vectorized）
 ↓
Access Method（Scan / Index）
 ↓
CPU + 内存 + 磁盘
 ↓
结果
```

---


