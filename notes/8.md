# ä¸€ã€è¿™é—¨è¯¾åˆ°åº•åœ¨è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ

ä¸€å¥è¯æ€»ç»“ï¼š

> **å½“å¾ˆå¤šçº¿ç¨‹åŒæ—¶è®¿é—®åŒä¸€ä¸ªç´¢å¼•ï¼ˆB+Treeã€å“ˆå¸Œè¡¨ï¼‰æ—¶ï¼Œå¦‚ä½•ä¿è¯ä¸ä¼šæŠŠç´¢å¼•ç»“æ„æåï¼Ÿ**

æ³¨æ„ä¸¤ä¸ªå…³é”®è¯ï¼š

* **åŒæ—¶è®¿é—®**
* **ç»“æ„ä¸æå**

è¿™é‡Œ**ä¸å…³å¿ƒäº‹åŠ¡éš”ç¦»ã€ä¸å…³å¿ƒè„è¯»å¹»è¯»**ï¼Œåªå…³å¿ƒä¸€ä»¶äº‹ï¼š

> ğŸ‘‰ **ç´¢å¼•è¿™ä¸ªâ€œæ•°æ®ç»“æ„â€æœ¬èº«ä¸èƒ½è¢«å¹¶å‘çº¿ç¨‹ç ´å**

---

# äºŒã€ä»€ä¹ˆæ˜¯å¹¶å‘æ§åˆ¶ï¼ˆConcurrency Controlï¼‰ï¼Ÿ

æƒ³è±¡ä¸€ä¸ªç°å®åœºæ™¯ ğŸ‘‡

* å¤šä¸ªäººåŒæ—¶åœ¨ **ä¿®æ”¹ä¸€ä»½ Excel**
* æœ‰äººæ’è¡Œã€æœ‰äººåˆ è¡Œã€æœ‰äººè¯»

å¦‚æœ**æ²¡æœ‰ä»»ä½•ä¿æŠ¤**ï¼Œå¯èƒ½ä¼šå‘ç”Ÿï¼š

* æŒ‡é’ˆä¹±äº†
* è¡Œå·ä¸å¯¹
* æ–‡ä»¶ç›´æ¥æŸåæ‰“ä¸å¼€

æ•°æ®åº“é‡Œçš„ **B+ æ ‘ / å“ˆå¸Œè¡¨** æœ¬è´¨ä¹Ÿæ˜¯ä¸€ä¸ªå¤æ‚çš„â€œå†…å­˜ç»“æ„â€ï¼Œ**å¹¶å‘è®¿é—®æ—¶å¿…é¡»ä¿æŠ¤**ã€‚

---

# ä¸‰ã€è¿™é—¨è¯¾åªå…³å¿ƒå“ªç§â€œæ­£ç¡®æ€§â€ï¼Ÿ

è¯¾ä¸Šè¯´æœ‰ä¸¤ç§æ­£ç¡®æ€§ï¼š

## 1ï¸âƒ£ é€»è¾‘æ­£ç¡®æ€§ï¼ˆLogical Correctnessï¼‰

> ä½ å†™è¿›å»çš„æ•°æ®ï¼Œä¹‹åè¿˜èƒ½è¯»å‡ºæ¥
> äº‹åŠ¡éš”ç¦»çº§åˆ«ã€å¯ä¸²è¡ŒåŒ– â€”â€” **ä»¥åè®²**

## 2ï¸âƒ£ ç‰©ç†æ­£ç¡®æ€§ï¼ˆPhysical Correctnessï¼‰âœ… æœ¬è®²é‡ç‚¹

> å†…å­˜ç»“æ„ä¸èƒ½å
> æŒ‡é’ˆä¸èƒ½é£
> ä¸è®¿é—®éæ³•å†…å­˜

ğŸ“Œ **è¿™èŠ‚è¯¾åªå…³å¿ƒç‰©ç†æ­£ç¡®æ€§**

---

# å››ã€é”ï¼ˆLockï¼‰ vs é”å­˜å™¨ï¼ˆLatchï¼‰ã€æå…¶é‡è¦ã€‘

è¿™æ˜¯ **DBMS å¹¶å‘é‡Œæœ€å®¹æ˜“æ··çš„ç‚¹**ã€‚

---

## 1ï¸âƒ£ Lockï¼ˆé”ï¼‰â€”â€”ç»™â€œç”¨æˆ·æ•°æ®â€ç”¨çš„

### ç‰¹ç‚¹

* ä¿æŠ¤ï¼š**è¡¨ / å…ƒç»„ / æ•°æ®åº“**
* ä½¿ç”¨è€…ï¼š**äº‹åŠ¡**
* æŒæœ‰æ—¶é—´ï¼š**å¾ˆé•¿ï¼ˆæ•´ä¸ªäº‹åŠ¡ï¼‰**
* æœ‰ï¼š**æ­»é”æ£€æµ‹ã€å›æ»šæœºåˆ¶**

### ä¾‹å­

```sql
BEGIN;
UPDATE student SET score=100 WHERE id=1;
-- äº‹åŠ¡è¿˜æ²¡ç»“æŸï¼Œé”è¿˜åœ¨
COMMIT;
```

ğŸ‘‰ è¿™ä¸ªé”ï¼Œ**ç”¨æˆ·èƒ½çœ‹åˆ°ã€ç³»ç»Ÿèƒ½å›æ»š**

---

## 2ï¸âƒ£ Latchï¼ˆé”å­˜å™¨ï¼‰â€”â€”ç»™â€œå†…éƒ¨ç»“æ„â€ç”¨çš„ï¼ˆæœ¬è®²ä¸»è§’ï¼‰

### ç‰¹ç‚¹

* ä¿æŠ¤ï¼š**å†…å­˜æ•°æ®ç»“æ„**

  * B+ æ ‘èŠ‚ç‚¹
  * å“ˆå¸Œæ¡¶
  * buffer pool é¡µ
* ä½¿ç”¨è€…ï¼š**DBMS å†…éƒ¨çº¿ç¨‹**
* æŒæœ‰æ—¶é—´ï¼š**æçŸ­**
* âŒ æ²¡æœ‰æ­»é”æ£€æµ‹
* âŒ ä¸ä¼šè‡ªåŠ¨å›æ»š

ğŸ“Œ **Latch æ˜¯ç¨‹åºå‘˜è‡ªå·±è´Ÿè´£â€œç”¨å®Œç«‹åˆ»æ”¾â€**

### ç±»æ¯”

| Lock  | Latch   |
| ----- | ------- |
| é“¶è¡Œè´¦æˆ·é” | ä¿®æ°´ç®¡æ—¶çš„æ‰³æ‰‹ |
| æŒæœ‰å¾ˆä¹…  | ç”¨å®Œå°±æ”¾    |
| æœ‰ç®¡ç†ç³»ç»Ÿ | ç¨‹åºå‘˜è‡ªè§‰   |

---

# äº”ã€Latch çš„ä¸¤ç§æ¨¡å¼ï¼ˆå’Œä½ ä¹‹å‰é—®çš„å®Œå…¨ä¸€è‡´ï¼‰

## 1ï¸âƒ£ READ Latchï¼ˆè¯»é”å­˜å™¨ï¼‰

* **å¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶æ‹¿**
* å‰æï¼šæ²¡æœ‰å†™é”

ğŸ‘‰ å°±åƒå›¾ä¹¦é¦†çœ‹ä¹¦
ğŸ‘‰ å¤§å®¶ä¸€èµ·çœ‹æ²¡é—®é¢˜

---

## 2ï¸âƒ£ WRITE Latchï¼ˆå†™é”å­˜å™¨ï¼‰

* **åªèƒ½ä¸€ä¸ªçº¿ç¨‹**
* è¯»çš„ã€å†™çš„ç»Ÿç»Ÿä¸å‡†è¿›

ğŸ‘‰ åƒç»´ä¿®é“è·¯
ğŸ‘‰ å°è·¯æ–½å·¥

---

# å…­ã€ä¸ºä»€ä¹ˆ DBMS ä¸çˆ±ç”¨ std::mutexï¼Ÿ

### std::mutex çš„é—®é¢˜

* ç”± **æ“ä½œç³»ç»Ÿç®¡ç†**
* å¤±è´¥äº†å°± **ç¡çœ  / å”¤é†’**
* æœ‰ç³»ç»Ÿè°ƒç”¨ â†’ æ…¢
* DBMS **æ²¡æ³•ç²¾ç»†æ§åˆ¶**

ğŸ“Œ DBMS æ˜¯é«˜æ€§èƒ½ç³»ç»Ÿ
ğŸ“Œ **ä¸€æ¡ç´¢å¼•æ“ä½œå¯èƒ½åªæƒ³ä¿æŠ¤å‡ åçº³ç§’**

---

# ä¸ƒã€Latch çš„åº•å±‚ï¼šåŸå­æŒ‡ä»¤ï¼ˆCASï¼‰

## CAS æ˜¯ä»€ä¹ˆï¼Ÿ

> Compare And Swap
> æ¯”è¾ƒå¹¶äº¤æ¢ï¼ˆCPU æŒ‡ä»¤ï¼‰

é€»è¾‘æ˜¯ï¼š

```text
if (M == old_value)
    M = new_value
else
    å¤±è´¥
```

âœ” æ•´ä¸ªè¿‡ç¨‹ **ä¸å¯è¢«æ‰“æ–­**

---

# å…«ã€ä¸‰ç§å¸¸è§ Latch å®ç°æ–¹å¼

---

## 1ï¸âƒ£ è‡ªæ—‹é”ï¼ˆSpin Latch / TASï¼‰

### æ€æƒ³

* ç”¨ä¸€ä¸ªåŸå­å˜é‡
* æ‹¿ä¸åˆ°å°± **while å¾ªç¯ç­‰**

### ä¼˜ç‚¹

* éå¸¸å¿«
* çº¯ç”¨æˆ·æ€
* æ— ç³»ç»Ÿè°ƒç”¨

### ç¼ºç‚¹

* é«˜å¹¶å‘ä¸‹æµªè´¹ CPU
* cache æŠ–åŠ¨ä¸¥é‡

ğŸ“Œ é€‚åˆï¼š**æçŸ­ä¸´ç•ŒåŒº**

---

## 2ï¸âƒ£ OS Mutexï¼ˆstd::mutexï¼‰

### Linux å®é™…ä¸Šæ˜¯ï¼š

* å…ˆè‡ªæ—‹
* ä¸è¡Œå°±è¿›å†…æ ¸ï¼ˆfutexï¼‰

### é—®é¢˜

* å†…æ ¸è°ƒåº¦å¾ˆè´µ
* DBMS å¤±å»æ§åˆ¶æƒ

ğŸ‘‰ **æ‰€ä»¥ DBMS é‡Œä¸€èˆ¬ä¸ç”¨**

---

## 3ï¸âƒ£ è¯»å†™é”å­˜å™¨ï¼ˆReader-Writer Latchï¼‰

### æ ¸å¿ƒç›®æ ‡

> **å¤šè¯»å°‘å†™åœºæ™¯ä¸‹æå‡å¹¶å‘**

### å†…éƒ¨åšäº†ä»€ä¹ˆï¼Ÿ

* ç»´æŠ¤ï¼š

  * å½“å‰è¯»è€…æ•°
  * æ˜¯å¦æœ‰å†™è€…
  * ç­‰å¾…é˜Ÿåˆ—

### ç­–ç•¥å·®å¼‚

* è¯»ä¼˜å…ˆï¼ˆå¯èƒ½é¥¿æ­»å†™ï¼‰
* å†™ä¼˜å…ˆï¼ˆå¯èƒ½é¥¿æ­»è¯»ï¼‰
* å…¬å¹³é”

ğŸ“Œ `std::shared_mutex` å°±æ˜¯è¿™ç§

---

# ä¹ã€å“ˆå¸Œè¡¨çš„å¹¶å‘æ§åˆ¶ï¼ˆæ¯”è¾ƒç®€å•ï¼‰

## ä¸ºä»€ä¹ˆå“ˆå¸Œè¡¨å¥½åšï¼Ÿ

* è®¿é—®è·¯å¾„ç®€å•
* ä¸ä¼šæ¥å›è·³
* ä¸ä¼šå½¢æˆç¯è·¯

ğŸ‘‰ **ä¸ä¼šæ­»é”**

---

## ä¸¤ç§ç²’åº¦

### 1ï¸âƒ£ Page Latchï¼ˆé¡µçº§ï¼‰

* ä¸€é¡µä¸€ä¸ª latch
* ç®€å•
* å¹¶å‘ä½

### 2ï¸âƒ£ Slot Latchï¼ˆæ§½çº§ï¼‰

* æ¯ä¸ªæ§½ä¸€ä¸ª latch
* å¹¶å‘é«˜
* å…ƒæ•°æ®å¤š

---

## ç”šè‡³å¯ä»¥æ— é”ï¼ˆCASï¼‰

* æ’å…¥ = CAS(null â†’ value)
* å¤±è´¥å°± probe ä¸‹ä¸€ä¸ªæ§½

ğŸ“Œ é«˜çº§ç©æ³•ï¼Œå·¥ç¨‹éš¾åº¦å¤§

---

# åã€B+Tree å¹¶å‘æ§åˆ¶ï¼ˆæœ€éš¾ã€æœ€é‡è¦ï¼‰

## é—®é¢˜ 1

> ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶æ”¹ä¸€ä¸ªèŠ‚ç‚¹ï¼Ÿ

## é—®é¢˜ 2

> ä¸€ä¸ªçº¿ç¨‹éå†ï¼Œå¦ä¸€ä¸ªçº¿ç¨‹ split / mergeï¼Ÿ

---

# åä¸€ã€Latch Crabbingï¼ˆèƒèŸ¹å¼åŠ é”ï¼‰

è¿™æ˜¯ **B+Tree å¹¶å‘çš„æ ¸å¿ƒæ€æƒ³**

---

## åŸºæœ¬è§„åˆ™

### æ°¸è¿œï¼š**ä»ä¸Šå¾€ä¸‹åŠ é”**

```text
Root
 â†“
Internal
 â†“
Leaf
```

âŒ ä¸å…è®¸åç€æ¥
ğŸ‘‰ **é¿å…æ­»é”**

---

## ä»€ä¹ˆå«â€œå®‰å…¨èŠ‚ç‚¹ï¼ˆSafe Nodeï¼‰â€ï¼Ÿ

### æ’å…¥æ—¶

* èŠ‚ç‚¹ **æ²¡æ»¡**

### åˆ é™¤æ—¶

* èŠ‚ç‚¹ **è¶…è¿‡åŠæ»¡**

 å®‰å…¨ = **ä¸ä¼š split / merge**

---

## åŸºæœ¬æ’å…¥æµç¨‹

1. é”çˆ¶èŠ‚ç‚¹
2. é”å­èŠ‚ç‚¹
3. å¦‚æœå­èŠ‚ç‚¹æ˜¯å®‰å…¨çš„

   * ç«‹åˆ»é‡Šæ”¾çˆ¶èŠ‚ç‚¹é”
4. ç»§ç»­å‘ä¸‹

ğŸ‘‰ **é”ä¸€è·¯å¾€ä¸‹â€œæ»‘â€**

---

# åäºŒã€ä¸ºä»€ä¹ˆè¦è¿™ä¹ˆåšï¼Ÿ

å› ä¸ºï¼š

* æ ¹èŠ‚ç‚¹é” = å…¨æ ‘ç“¶é¢ˆ
* è¶Šå¾€ä¸Šï¼Œå½±å“èŒƒå›´è¶Šå¤§

ğŸ“Œ **èƒ½æ—©æ”¾å°±æ—©æ”¾**

---

# åä¸‰ã€ä¹è§‚é”å­˜ï¼ˆOptimistic Crabbingï¼‰

## é—®é¢˜

> æ¯æ¬¡æ’å…¥éƒ½ X-lock root
> å¹¶å‘å¤ªå·®

---

## ä¹è§‚æ€è·¯

> **å‡è®¾ä¸ä¼š splitï¼ˆé€šå¸¸æ˜¯çœŸçš„ï¼‰**

---

## åšæ³•

1. ä¸€è·¯ç”¨ **è¯»é”**
2. åˆ°å¶å­ï¼Œå°è¯•å‡çº§å†™é”
3. å¦‚æœå‘ç°ä¸å®‰å…¨

   * å…¨éƒ¨é‡Šæ”¾
   * é‡æ¥ï¼ˆæ‚²è§‚æ¨¡å¼ï¼‰

ğŸ“Œ ç±»ä¼¼æ•°æ®åº“çš„ **ä¹è§‚å¹¶å‘æ§åˆ¶**

---

# åå››ã€å¶å­èŠ‚ç‚¹æ‰«æçš„é—®é¢˜ï¼ˆéå¸¸ç»†èŠ‚ï¼‰

## é—®é¢˜å‡ºç°åœ¨å“ªé‡Œï¼Ÿ

* æ’å…¥/åˆ é™¤ï¼šè‡ªä¸Šè€Œä¸‹
* å¶å­æ‰«æï¼šå·¦å³ç§»åŠ¨

ğŸ‘‰ **é”æ–¹å‘å†²çª**

---

## ä¸ºä»€ä¹ˆä¸èƒ½æ­»é”æ£€æµ‹ï¼Ÿ

* Latch æ²¡æœ‰äº‹åŠ¡ ID
* æ²¡æœ‰ wait-for graph
* æˆæœ¬å¤ªé«˜

---

## è§£å†³æ–¹æ¡ˆï¼šNo-Wait

> æ‹¿ä¸åˆ°é”ï¼Ÿ
> ğŸ‘‰ ç«‹åˆ»æ”¾å¼ƒï¼Œé‡æ¥

ğŸ“Œ å› ä¸º latch æŒæœ‰æ—¶é—´æçŸ­
ğŸ“Œ é‡æ¥æˆæœ¬ä½

---

# åäº”ã€æ•´è®²ä¸€å¥è¯æ€»ç»“

> **ç´¢å¼•å¹¶å‘æ§åˆ¶çš„æœ¬è´¨æ˜¯ï¼š**
>
> * é”ä½â€œç»“æ„â€ï¼Œä¸æ˜¯æ•°æ®
> * é”å¾—è¶Šç»†ï¼Œå¹¶å‘è¶Šé«˜
> * æ°¸è¿œæ§åˆ¶åŠ é”é¡ºåº
> * å®æ„¿é‡è¯•ï¼Œä¹Ÿä¸è¦æ­»é”

---
==è¡¥å……==ï¼š
**è‡ªæ—‹é”çš„å®ç°**
```c
#include <iostream>
#include <thread>
#include <atomic>
#include <vector>

// è‡ªæ—‹é”çš„å®ç°
class Spinlock {
public:
    // æ„é€ å‡½æ•°
    Spinlock() : flag(false) {}

    // è·å–é”
    void lock() {
        // å½“ flag ä¸º true æ—¶ï¼Œè¡¨ç¤ºé”å·²ç»è¢«å…¶ä»–çº¿ç¨‹æŒæœ‰ï¼Œå½“å‰çº¿ç¨‹è¿›å…¥è‡ªæ—‹ç­‰å¾…
        while (flag.exchange(true, std::memory_order_acquire)) {
            // è‡ªæ—‹ç­‰å¾…ï¼Œç›´åˆ° flag ä¸º falseï¼Œè¡¨ç¤ºé”å·²è¢«é‡Šæ”¾
            std::this_thread::yield(); // é¿å…å ç”¨è¿‡å¤š CPU æ—¶é—´
        }
    }

    // é‡Šæ”¾é”
    void unlock() {
        // é‡Šæ”¾é”ï¼Œå°† flag è®¾ç½®ä¸º false
        flag.store(false, std::memory_order_release);
    }

private:
    std::atomic<bool> flag; // æ ‡è®°é”çš„çŠ¶æ€
};

// å…±äº«èµ„æº
int shared_resource = 0;

// çº¿ç¨‹ä»»åŠ¡
void thread_task(Spinlock& spinlock, int thread_id) {
    // è·å–é”
    spinlock.lock();
    
    // æ“ä½œå…±äº«èµ„æº
    ++shared_resource;
    std::cout << "Thread " << thread_id << " incremented shared_resource to " << shared_resource << std::endl;
    
    // é‡Šæ”¾é”
    spinlock.unlock();
}

int main() {
    Spinlock spinlock; // åˆ›å»ºé”å­˜å™¨

    // åˆ›å»ºå¤šä¸ªçº¿ç¨‹
    std::vector<std::thread> threads;
    for (int i = 0; i < 5; ++i) {
        threads.push_back(std::thread(thread_task, std::ref(spinlock), i));
    }

    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
    for (auto& t : threads) {
        t.join();
    }

    std::cout << "Final value of shared_resource: " << shared_resource << std::endl;
    return 0;
}
```
è¯»å†™é”ç±»ï¼ˆRWLatchï¼‰
```c
#include <mutex>
#include <condition_variable>

class RWLatch {
public:
    RWLatch() : reader_cnt_(0), writer_(false) {}

    // è¯»é”
    void RLock() {
        std::unique_lock<std::mutex> lock(mu_);
        cv_.wait(lock, [&]() {
            return !writer_;  // åªè¦æ²¡æœ‰å†™è€…ï¼Œå°±å¯ä»¥è¯»
        });
        reader_cnt_++;
    }

    // é‡Šæ”¾è¯»é”
    void RUnlock() {
        std::unique_lock<std::mutex> lock(mu_);
        reader_cnt_--;
        if (reader_cnt_ == 0) {
            cv_.notify_all();  // å”¤é†’å¯èƒ½åœ¨ç­‰å†™é”çš„çº¿ç¨‹
        }
    }

    // å†™é”
    void WLock() {
        std::unique_lock<std::mutex> lock(mu_);
        cv_.wait(lock, [&]() {
            return !writer_ && reader_cnt_ == 0;
        });
        writer_ = true;
    }

    // é‡Šæ”¾å†™é”
    void WUnlock() {
        std::unique_lock<std::mutex> lock(mu_);
        writer_ = false;
        cv_.notify_all();
    }

private:
    std::mutex mu_;
    std::condition_variable cv_;
    int reader_cnt_;
    bool writer_;
};
```
