

## 一、概括

> **Timestamp Ordering（时间戳并发控制）和 OCC（乐观并发控制）的核心思想是：
> 不提前挡你（不加锁），先让你跑，最后再检查你有没有闯祸。**

和 2PL 正好相反：

| 思路               | 代表                       |
| ---------------- | ------------------------ |
| **悲观**：我先假设你们会冲突 | 2PL（加锁）                  |
| **乐观**：我假设你们很少冲突 | Timestamp Ordering / OCC |

---

## 二、什么是 Timestamp Ordering（时间戳排序）

### 1️⃣ 给每个事务一个“出生时间”

DBMS 给每个事务分配一个 **唯一、递增的时间戳**：

```
T1：TS = 10
T2：TS = 20
T3：TS = 30
```

规则只有一句话：

> **如果 TS(Ti) < TS(Tj)，那最终效果必须“看起来像” Ti 在 Tj 之前执行**

⚠️ 注意：
不是“真的按顺序执行”，
而是 **结果等价于按这个顺序串行执行**（可串行化）。

---

### 2️⃣ 不加锁，靠规则来“否决”非法操作

在 Timestamp Ordering 里：

* **读 / 写操作不会被阻塞**
* 但如果发现 **破坏时间顺序** → **直接 abort（回滚）事务**

所以它的哲学是：

> **不阻塞、不等待，冲突了就回滚**

---

## 三、Timestamp Ordering 的底层直觉（非常重要）

你可以把数据库想成这样：

* 每条数据都“记住”：

  * 最近一次被谁 **读过**
  * 最近一次被谁 **写过**

比如对数据 X：

```
read_ts(X)  = 15
write_ts(X) = 12
```

意思是：

* 最晚 **读 X 的事务时间戳是 15**
* 最晚 **写 X 的事务时间戳是 12**

---

### 写操作的核心规则（直觉版）

假设事务 Ti（TS=20）想写 X：

* ❌ 如果 **有“未来的人”已经读过 X**

  * 即：`read_ts(X) > TS(Ti)`
  * 说明：**已经有人用“更新后的世界”看过 X**
  * 👉 Ti 写 X 就等于“篡改历史”
  * 👉 **Ti 必须 abort**

* ❌ 如果 **有“未来的人”已经写过 X**

  * 即：`write_ts(X) > TS(Ti)`
  * 👉 Ti 的写已经过期
  * 👉 abort

* ✅ 否则：允许写，更新 write_ts(X)

本质一句话：

> **老事务不能覆盖新事务看过或写过的东西**

---

## 四、OCC（Optimistic Concurrency Control）——Timestamp 的“工程版”

Timestamp Ordering 是思想，
**OCC 是工程实现中最常见的一种形式**。

---

## 五、OCC 的核心模型：私有工作区（Private Workspace）

### 1️⃣ 每个事务都有自己的“小房间”

* 事务 **不直接改数据库**
* 而是：

  * 读 → 拷贝一份到自己的 workspace
  * 写 → 只写在 workspace 里

其他事务：

* **完全看不到你的修改**
* 就像你在“草稿纸”上写东西

---

### 2️⃣ OCC 的三大阶段（非常关键）

#### 🟢 第一阶段：Read Phase（读阶段）

事务在这里：

* 读数据 → 拷贝到私有区
* 写数据 → 只写私有区
* 记录：

  * **ReadSet**
  * **WriteSet**

⚠️ 这一步：

* 不加锁
* 不检查冲突
* 跑得飞快

---

#### 🟡 第二阶段：Validation Phase（验证阶段）

事务准备提交时：

* DBMS 给它分配一个 **时间戳**
* 开始问一个问题：

> **“你刚才干的事，会不会和别人打架？”**

也就是：

* 你的 **ReadSet / WriteSet**
* 和别的事务的 **ReadSet / WriteSet**
* 是否违反“时间顺序”

---

#### 🔵 第三阶段：Write Phase（写阶段）

* ✅ 验证通过：

  * 一次性把 workspace 的修改 **原子地写回数据库**
* ❌ 验证失败：

  * **直接 abort**
  * 一切白干

📌 非常重要的一点：

> **OCC 的 abort，通常发生在“干完所有活之后”**

所以它：

* 冲突少 → 性能爆炸好
* 冲突多 → 白干很多活

---

## 六、Validation（验证）到底在检查什么？

这是最容易懵的一部分，我用 **直觉 + 例子** 来讲。

---

### 核心目标

保证：

> **所有冲突都“方向一致”
> 不会出现时间倒流**

---

## 七、Forward Validation vs Backward Validation

### 1️⃣ Forward Validation（向前检查）

检查对象：

* **还在运行、没提交的事务**

逻辑是：

> “我（老事务）会不会和将来的事务冲突？”

现实中 **较少用**，因为：

* 要盯着所有活跃事务
* 成本高

---

### 2️⃣ Backward Validation（向后检查）✅ 常用

检查对象：

* **已经提交的事务**
* 且这些事务：

  * 在我开始之后提交

逻辑是：

> “有没有已经提交的人，
> 和我发生了时间冲突？”

👉 **更容易实现，更常见**

---

## 八、Validation 的三条规则

假设：

* Ti 是“老事务”
* Tj 是“新事务”
* TS(Ti) < TS(Tj)

### ✅ 情况 1：完全串行

> Ti 写完了
> Tj 才开始读

✔️ 没问题

---

### ✅ 情况 2：Ti 不写 Tj 读的东西

```
WriteSet(Ti) ∩ ReadSet(Tj) = ∅
```

意思是：

> Ti 改的东西
> Tj 根本没看

✔️ 没冲突

---

### ✅ 情况 3：完全不交集

```
WriteSet(Ti) ∩ ReadSet(Tj) = ∅
WriteSet(Ti) ∩ WriteSet(Tj) = ∅
```

意思是：

> 你改你的
> 我改我的
> 完全不相干

✔️ 安全

---

❌ 只要不满足这些条件之一 → abort

---

## 九、OCC 最适合什么场景？

### 🌟 理想场景

* 读多写少
* 大数据库
* 数据访问分散
* 冲突概率低

比如：

* 分析型查询
* 内存数据库
* 多核 CPU

---

### ❌ 不适合的场景

* 热点数据
* 大量写冲突
* 高并发更新同一行

因为：

* abort 代价很大
* 白干活太多

---

## 十、Phantom Problem（幻读）——Timestamp 的硬伤之一

### 什么是幻读？

事务 T1：

```sql
SELECT * FROM users WHERE age > 18;
```

结果是 10 行。

此时 T2：

```sql
INSERT INTO users VALUES (age=20);
```

T1 再执行同样的查询：

```sql
SELECT * FROM users WHERE age > 18;
```

结果变成 11 行。

👉 **像“凭空多出来一条记录”**

---

### 为什么会发生？

因为：

* Timestamp / OCC 默认只关心：

  * **已有对象**
* 但：

  * **新插入的对象**
  * 之前根本“不存在”

👉 所以不会被检测为冲突

---

## 十一、解决幻读的 4 种方法（通俗解释）

### 1️⃣ 锁整个表（最暴力）

* 不让别人插 / 删
* 简单
* 并发性最差

---

### 2️⃣ 提交时重跑查询

* 记住 WHERE 条件
* 提交时再跑一遍
* 结果变了 → abort

✔️ 准确
❌ 慢

---

### 3️⃣ 谓词锁（Predicate Lock）

* 锁的是：

  * “所有 age > 18 的东西”
* 理论上完美
* 实现极其复杂

👉 学术派

---

### 4️⃣ 索引锁（现实世界的王者）👑

通过 **B+ 树索引**：

* 锁 key
* 锁 gap
* 锁 range

比如：

* **Gap Lock**：锁住“18 ~ 25 之间”
* 防止插入

👉 **MySQL / PostgreSQL 广泛使用**

---

## 十二、隔离级别（Isolation Levels）

这是前面所有理论的 **落地版本**。

### 从强到弱：

| 隔离级别             | 会发生什么    |
| ---------------- | -------- |
| SERIALIZABLE     | 什么问题都没有  |
| REPEATABLE READ  | 可能幻读     |
| READ COMMITTED   | 不可重复读、幻读 |
| READ UNCOMMITTED | 脏读、啥都可能  |

不同 DBMS：
* 用 2PL
* 用 OCC
* 用 MVCC
* 用混合方案

---

## 十三、和 2PL 的终极对比（帮你形成体系）

| 维度   | 2PL | Timestamp / OCC |
| ---- | --- | --------------- |
| 思想   | 悲观  | 乐观              |
| 是否加锁 | 是   | 否               |
| 是否阻塞 | 会   | 不会              |
| 冲突处理 | 等待  | 回滚              |
| 冲突多时 | 稳定  | 灾难              |
| 冲突少时 | 保守  | 极快              |

---

## 十四、一句终极总结

> **Timestamp Ordering / OCC 用时间戳来规定事务的“历史顺序”，
> 不通过锁来阻止冲突，而是在提交时检测冲突，
> 冲突则回滚，从而保证可串行化。**

