### 一、背景（Background）
#### 1️⃣ 单线程 vs 多线程

* 以前的查询执行假设是在 **单线程** 执行的。但在现实中，查询通常会用 **多线程并行执行**。
* **并行执行** 让数据库在多个资源上同时工作。资源可以是：

  * 计算资源（如多个 CPU 核心、GPU）
  * 存储资源（如多个磁盘、内存）
### 2️⃣ 为什么要并行执行？

**并行执行的好处：**

* **处理大数据集**：当数据量太大，单台机器无法处理时，分布到多个机器上可以让它们一起工作。
* **提升性能**：多个工作线程同时运行，处理速度更快。
* **容错性高**：分布式资源，能容忍部分机器/节点故障。

**并行执行分为两种：**

1. **查询间并行**（Inter-query Parallelism）
2. **查询内并行**（Intra-query Parallelism）

---

### 二、并行数据库 vs 分布式数据库（Parallel vs Distributed Databases）

#### 1️⃣ 并行数据库（Parallel DBMS）

* **物理位置近**：资源和节点很近，通信速度快且可靠。
* **资源管理**：节点间的通信是高效的，通常是通过 **高速互联** 连接。

#### 2️⃣ 分布式数据库（Distributed DBMS）

* **物理位置远**：节点可能分布在不同的数据中心，或者全球分布，通信的延迟会大一些。
* **通信成本高**：节点之间的通信通过 **公共网络**，导致开销更大。

#### 3️⃣ 重要区别

尽管物理上分布在多个资源上，查询在 **并行** 和 **分布式数据库** 中**看起来都是一个单一数据库实例**，执行结果是相同的。

---

### 三、DBMS 进程模型（Process Models）

一个 **DBMS 进程模型** 定义了数据库如何支持并发请求。常见的模型有：

1. **进程模型（Process per Worker）**
2. **线程模型（Thread per Worker）**
3. **嵌入式数据库（Embedded DBMS）**

#### 1️⃣ 进程模型（Process per Worker）

* 每个工作单元都由 **独立的操作系统进程** 管理。
* 每个进程有自己的内存空间，互不干扰。
* 这个模型的优点是 **稳定性**：一个进程崩溃不会影响整个系统。

#### 2️⃣ 线程模型（Thread per Worker）

* 每个 DBMS 是 **一个单独的进程**，并且通过多个 **线程** 来处理任务。
* 线程模型的优点：**更少的上下文切换**，没有操作系统干扰。
* 这个模型的问题：**线程崩溃** 会导致整个进程崩溃，稳定性不如进程模型。

#### 3️⃣ 嵌入式数据库（Embedded DBMS）

* 数据库与应用程序 **共享内存空间**，不依赖于客户端-服务器模型。
* 比如 **SQLite** 和 **RocksDB** 就是这种嵌入式数据库。

---

### 四、并行性：查询间 vs 查询内并行（Inter-Query Parallelism vs Intra-Query Parallelism）

#### 1️⃣ 查询间并行（Inter-query Parallelism）

* **概念**：不同的查询同时执行。
* **好处**：提升吞吐量，减少等待时间。
* **适用场景**：当有多个独立查询时，它们可以同时执行而不相互干扰。

#### 2️⃣ 查询内并行（Intra-query Parallelism）

* **概念**：一个查询的不同部分同时执行。
* **好处**：**减少查询执行的总时间**。
* **生产者-消费者模型**：每个算子是生产者（产生数据）也是消费者（接收来自上游的数据）。

##### a) **内部并行有三种类型**：

1. **操作符内部并行（Intra-Operator Parallelism）**：把一个操作分成若干个子任务，并行处理。
2. **操作符间并行（Inter-Operator Parallelism）**：不同操作符之间并行（通常是流处理系统）。
3. **混合并行（Bushy Parallelism）**：结合内部并行和操作符间并行，多个操作同时并行执行。

#### 3️⃣ 示例：Intra-Operator Parallelism（操作符内部并行）

假设有一个 **查询计划**，它做了一个顺序扫描并过滤数据。为了并行化：

* 将扫描的工作分成若干块，每块交给一个工作线程执行。
* 然后再通过 **交换操作符（Exchange Operator）** 将所有结果合并。

##### **三种交换操作符**：

1. **Gather**：把多个线程的结果合并成一个输出。
2. **Distribute**：把一个输入流分成多个输出流。
3. **Repartition**：重新分配多个输入流到多个输出流。

---

### 五、I/O 并行性（I/O Parallelism）

I/O 并行性是在查询执行时，通过将数据分布到 **多个存储设备** 上来提升性能。

#### 1️⃣ **多磁盘并行（Multi-Disk Parallelism）**

* 通过使用 **RAID** 或存储设备的集群，把 DBMS 的数据文件分布到多个磁盘上。
* 磁盘间的并行操作可以 **加速数据读取**。

#### 2️⃣ **数据库分区（Database Partitioning）**

* 将数据库分成多个物理部分，并把它们分配到不同的磁盘上存储。
* 每个分区可以独立存取，这样就能提高 **查询性能**。

---

### 六、总结
1. **多线程和进程模型** 是 **DBMS 并行执行的基础**。
2. **并行执行** 既可以应用在**多个查询同时执行**，也可以在 **单个查询内部并行执行**，比如把查询计划拆分成多个部分同时进行处理。
3. **I/O 并行性** 利用多个磁盘或存储设备，减少了磁盘瓶颈，提高了性能。


